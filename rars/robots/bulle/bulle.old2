//__________________________________________________________________________
//
// BULLE.CPP - A robot "driver" for RARS ver. 0.73
//
// Filename:  bulle.cpp
// Robot:     bulle
// Author:    Marc Gueury, marc.gueury@skynet.be (Belgium)
// Races:     all
// Source:    Public
// Data:      -
//
//__________________________________________________________________________


//////////////////////////  I N C L U D E S  ///////////////////////////////

#include <string.h>                      // strcpy
#include <math.h>                        // fabs, sqrt
#include <stdio.h>
#include <stdlib.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#include "car.h"                         // stuck
#include "track.h"
#include "os.h"
#include "misc.h"                        // alpha_limit, collide

//#define BULLE_HOME
#ifdef BULLE_HOME
   #include "_bulle.h"
   // #include "_track.h"
#endif // BULLE_HOME

// paste here bulle.h
#ifndef BULLE_HOME
/////////////////////////// B U L L E . H /////////////////////////////////

#define STRAIGHT_RAD         100000.0   // radius for straigths
#define STRAIGHT_SPD           400.00   // speed for straights
#define MAX_SEG                    90   // max segments (gTrack)
#define MAX_CURVE                  50   // max curves (gCurve)
#define TPARAM_NB                  36   // number of parameters

// curve types
#define CUR_ST 0
#define CUR_LC 1
#define CUR_RC 2

////////////////////////////  M A C R O S  /////////////////////////////////

#ifndef max 
  #define max(x,y)                (((x)<(y))?(y):(x))        // return maximum
  #define min(x,y)                (((x)>(y))?(y):(x))        // return minimum
#endif
#define sqr(x)                  ((x)*(x))                  // return x}
#define my_mod(x,y)             (((x)<(y))?(x):(x-y))      // return absolute

////////////////////////////// T Y P E S //////////////////////////////////

typedef struct {
  int alpha;
  int speed;
} tControl;

typedef struct {
 // one for each half segment
      double r1;           // internal radius
      double r2; 	   // radius ST_CV_ST
      double d1; 	   //
      double d3; 	   //
      double speed;        // speed
      tControl control;    // type of controle
} T_track_sub;

typedef struct {
   // ST_CV_ST
   double length;       // length
   T_track_sub t[2];

   // type
   int type;
   int curve;           // curve number
} T_track ;

typedef struct {
   double in;
   double out;
   double out2;
} T_border;

typedef struct {
    char   trackfile[16];           // track file name
    int    surface;                 // surface type

    double DECEL;                   // braking deceleration
    double START_ACC;               // fraction of seg. len. to start acc.
    double START_ACC2;              // fraction of seg. len. to start acc.
    double BORDER_IN;               // internal border
    double BORDER_OUT;              // external border
    double BORDER_OUT2;             // external border
    double SPEED_MAG;               // coef. for speed in normal curve
    double SPEED_MAG_MIN;           // coef. for speed in slow curve

    double ALPHA_START;             // alpha=0 for xxx dt
    double ALPHA_MAG_INI;           // bAlpha, AM initial
    double SLIDE_MAG_INI;           // bAlpha, SM initial
    double STRAIGTH_SHORT2;         // bGetCurveType qLongStraight2
    double STRAIGTH_SHORT3;         // bGetCurveType qLongStraight3
    double ALPHA_MAG_S_OUTSIDE;     // bAlpha, s.outside
    double SLIDE_MAG_S_OUTSIDE;     // bAlpha, s.outside
    double SLIDE_MAG_S_NXT;  	    // bAlpha, s.nxt
    double ALPHA_MAG_S_PRV;  	    // bAlpha, s.prv
    double SLIDE_MAG_S_PRV;         // bAlpha, s.prv
    double ALPHA_MAG_S_MIX;  	    // bAlpha, s.mix
    double ALPHA_MAG_S_MIX2;        // bAlpha, s.mix2
    double SLIDE_MAG_S_MIX2;        // bAlpha, s.mix2
    double ALPHA_MAG_S_MIX2b;       // bAlpha, s.mix2
    double SLIDE_MAG_S_MIX2b;       // bAlpha, s.mix2
    double ALPHA_MAG_S_MIX3;        // bAlpha, s.mix3
    double SLIDE_MAG_S_MIX3;        // bAlpha, s.mix3
    double ALPHA_MAG_S_MIX4;        // bAlpha, s.mix4
    double SLIDE_MAG_S_MIX4;        // bAlpha, s.mix4
    double ALPHA_MAG_C_INSIDE;      // bAlpha, c.inside
    double SLIDE_MAG_C_INSIDE;      // bAlpha, c.inside
    double ALPHA_MAG_C_1H_OUTSIDE;  // bAlpha, c.1H outside
    double SLIDE_MAG_C_1H_OUTSIDE;  // bAlpha, c.1H outside
    double ALPHA_MAG_C_2H_OUTSIDE;  // bAlpha, c.2H outside
    double SLIDE_MAG_C_2H_OUTSIDE;  // bAlpha, c.2H outside
    double ALPHA_MAG_C_1H_IN_S;     // bAlpha, c.1H in S
    double SLIDE_MAG_C_1H_IN_S;     // bAlpha, c.1H in S
    double ALPHA_MAG_C_2H_IN_S;     // bAlpha, c.2H in S
} T_param;

typedef struct {
   double s1;       // speed segment 1
   double s2;       // speed segment 2
} T_speed_sub;

typedef struct {
    char   trackfile[16];           // track file name
    int    surface;                 // surface type
    // speed
    T_speed_sub speed[ MAX_SEG ];
    // alpha_mag, slide_mag
    int    AlphaNb;
    T_speed_sub alpha[ MAX_SEG ];
    // border_in, border_out
    double border_in[ MAX_SEG ];
    int alpha_cpt[ MAX_SEG ];
} T_speed ;

/////////////////////  E N D   O F   B U L L E . H  ///////////////////////
#endif // BULLE_HOME
///////////////////////////  E X T E R N S  ////////////////////////////////

// BULLE.CPP
   double bSpeed2( int seg, int half, tControl &c );

// CARZ.CPP
   // variables
   extern int no_display;
   extern Car* pcar[];
   extern int car_count;
   extern int lap[MAXCARS];
   // functions
   int farther(Car* car0, Car* car1);

#ifdef BULLE_HOME
// _OPTI.CPP
   // variables
   extern double gOpti;
   extern double gOptiOne;
   extern int OPTI_PARAM2;
   extern int gOptiCycle;

   // functions
   void OptiSaveOne( T_speed_sub * a, int pos, double d1, double d2 );
   void OptiSaveOne2( double * a, int pos, double d );
   void OptiSaveOneInt( int * a, int pos, int d );
#endif

////////////////////////////// T Y P E S //////////////////////////////////

#define OLD_CPT_MIN 5.0

typedef struct {
  int laps;             // number of laps
  int when;             // last time the car crossed the finishing line
  double old_avg;       // last average time

  int old_cpt;
  double old_vx;
  double old_vy;
  int bVisible;
} T_car;

//////////////////////////////// D A T A //////////////////////////////////

static T_param pdata[] =
{
  { "default", // name
     0,         // surface
     35.0,      // DECEL
     0.97,      // START_ACC
     0.35,      // START_ACC2
     1,         // BORDER_IN
     13,        // BORDER_OUT
     13,        // BORDER_OUT2
     5.0,       // SPEED_MAG
     6.0,       // SPEED_MAG_MIN
     50.0,      // ALPHA_START
     0.03,     	// ALPHA_MAG_INI
     2.0,   	// SLIDE_MAG_INI
     200.0,     // STRAIGTH_SHORT2
     0.30,      // STRAIGTH_SHORT3
     0.01,      // ALPHA_MAG_S_OUTSIDE
     1.960938,  // SLIDE_MAG_S_OUTSIDE
     2.00,      // SLIDE_MAG_S_NXT
     0.01,      // ALPHA_MAG_S_PRV
     2.0,       // SLIDE_MAG_S_PRV
     0.01,      // ALPHA_MAG_S_MIX
     0.0475,    // ALPHA_MAG_S_MIX2
     2.1250,    // SLIDE_MAG_S_MIX2
     0.0125,    // ALPHA_MAG_S_MIX2b
     2.0000,    // SLIDE_MAG_S_MIX2b
     0.0220,    // ALPHA_MAG_S_MIX3
     1.03125,   // SLIDE_MAG_S_MIX3
     0.03,      // ALPHA_MAG_S_MIX4
     2.0,       // SLIDE_MAG_S_MIX4
     0.02150,   // ALPHA_MAG_C_INSIDE
     3.851562,  // SLIDE_MAG_C_INSIDE
     0.024219,  // ALPHA_MAG_C_1H_OUTSIDE
     1.906250,  // SLIDE_MAG_C_1H_OUTSIDE
     0.008750,  // ALPHA_MAG_C_2H_OUTSIDE
     2.100,     // SLIDE_MAG_C_2H_OUTSIDE
     0.020,     // ALPHA_MAG_C_1H_IN_S
     2.00,      // SLIDE_MAG_C_1H_IN_S
     0.030      // ALPHA_MAG_C_2H_IN_S
  }
// speed optimization
  ,{ "adelaid2.trk", 1, 32.409667,  0.900000,  0.341699,  1.430859,  8.193359,  9.816406,  6.067871,  6.507812, 80.091797,  0.030000,  1.578125, 52.343750,  0.300000,  0.015000,  2.003907,  1.171875,  0.015000,  2.000000,  0.030000,  0.031875,  2.093750,  0.034141,  2.503906,  0.029969,  1.843751,  0.030000,  2.078150,  0.015000,  3.429687,  0.017656,  1.859375,  0.015000,  1.350000,  0.027578,  2.000000,  0.038438 }
  ,{ "buenos.trk", 1, 39.101563,  1.420000,  0.366016,  4.118750, 23.500000, 12.062500,  5.601562,  4.795898, 231.445312,  0.076563,  1.914062, -103.906250,  0.416016,  0.038047,  2.000001,  2.000000,  0.017304,  1.617188,  0.030000,  0.030000,  2.000000,  0.028907,  1.857422,  0.018094,  1.217773,  0.057344,  0.918945,  0.015000,  3.282227,  0.023907,  1.359375,  0.015000,  2.100000,  0.015664,  1.998047,  0.030195 }
  ,{ "imola.trk", 1, 37.949219,  1.141094,  0.256250,  3.859375, 19.937500, 20.500000,  5.645508,  6.199708,  7.812500,  0.030000,  1.734375, -188.281250,  0.300000,  0.028096,  2.375978,  1.705078,  0.017578,  0.968750,  0.030000,  0.030000,  2.000000,  0.037270,  1.819337,  0.035840,  2.387695,  0.030314,  2.400390,  0.026943,  2.000977,  0.028429,  1.003418,  0.015000,  0.625000,  0.015000,  1.334961,  0.015469 }
  ,{ "ra.trk", 1, 40.810547,  1.228398,  0.410937,  0.980078, 18.398438, 16.015625,  5.313966,  5.897216, 349.218750,  0.006796,  2.000000, 172.505859,  0.300000,  0.010000,  1.370118,  1.509766,  0.010000,  1.162597,  0.030000,  0.030000,  2.000000,  0.030557,  2.078125,  0.010000,  1.313476,  0.025498,  1.750000,  0.010000,  1.325683,  0.010000,  1.666993,  0.010000,  1.387598,  0.030000,  2.000000,  0.030000 }
  ,{ "montreal.trk", 1, 42.485352,  1.206914,  0.446875,  4.537500, 15.906250, 22.125000,  5.044922,  6.980469, 74.902344,  0.015156,  2.191406, -151.562500,  0.300000,  0.015312,  1.386719,  2.060547,  0.021406,  2.000000,  0.030000,  0.030000,  2.000000,  0.015000,  1.570313,  0.037508,  1.992188,  0.036172,  1.937500,  0.023219,  1.390624,  0.024219,  1.781250,  0.015000,  1.975000,  0.020000,  2.121094,  0.029883 }

  ,{ "brands.trk", 1, 36.757813,  1.060625,  0.196875,  4.093750, 13.968750, 21.687500,  5.595703,  5.512695, 79.687500,  0.027657,  1.179688, 32.031250,  0.300000,  0.021875,  2.000001,  1.828125,  0.015938,  2.000000,  0.030000,  0.027500,  1.875000,  0.030938,  2.003906,  0.051297,  1.843750,  0.030000,  2.000000,  0.030156,  2.808594,  0.029218,  1.089844,  0.015000,  1.846094,  0.022969,  2.000000,  0.027031 }
  ,{ "cstlcomb.trk", 1, 39.003906,  1.354374,  0.362500,  4.478125,  6.921875, 12.593750,  5.475098,  6.258301,  3.906250,  0.029376,  2.000000, 200.000000,  0.300000,  0.031348,  1.722657,  2.002930,  0.015000,  1.484375,  0.030000,  0.030000,  2.000000,  0.030665,  3.052735,  0.029500,  1.968750,  0.030000,  2.000000,  0.029235,  3.957031,  0.030625,  1.976563,  0.015000,  2.089258,  0.030000,  2.000000,  0.030000 }
  ,{ "monaco.trk", 1, 55.644532,  1.189531,  0.221875,  4.621094, 14.312500, 19.695313,  5.000000,  6.726563, 43.945313,  0.026875,  1.669922, -34.375000,  0.300000,  0.015078,  1.464844,  1.312500,  0.019687,  1.109376,  0.030000,  0.030000,  2.000000,  0.015000,  1.658203,  0.053711,  2.015625,  0.015117,  2.011719,  0.031031,  0.500000,  0.022071,  1.324219,  0.015000,  1.068750,  0.025469,  1.697266,  0.017500 }
  ,{ "speed2.trk", 1, 50.664063,  1.223125,  0.406250,  5.962500,  7.546875, 20.812500,  5.097656,  8.156250, 275.390625,  0.028047,  2.000000, 175.000000,  0.300000,  0.015000,  2.000001,  2.000000,  0.015000,  1.679688,  0.030000,  0.027500,  2.125000,  0.015000,  1.820313,  0.032000,  2.031250,  0.030000,  2.000000,  0.015000,  5.734374,  0.026250,  1.906250,  0.015000,  2.764062,  0.030000,  2.000000,  0.030000 }
  ,{ "watglen.trk", 1, 44.584961,  1.087382,  0.327344,  0.985156, 11.500000, 20.796875,  5.300781,  6.608887,  8.789063,  0.042969,  2.000000, 133.593750,  0.300000,  0.026250,  1.339844,  2.000000,  0.020078,  2.015625,  0.030000,  0.030000,  2.000000,  0.030000,  2.000000,  0.015000,  0.937500,  0.030000,  2.000000,  0.023437,  3.707030,  0.015391,  1.492188,  0.015000,  1.857812,  0.030000,  2.000000,  0.030000 }


// without speed optimization
  // Time:259.424747 // Laps: 2 // Avg:90.886327
  ,{ "albrtprk.trk", 1, 45.390625,  1.418438,  0.350000,  4.937500, 19.515625, 12.968750,  4.937500,  5.632813, 174.218750,  0.028750,  1.531250, 30.078125,  0.300000,  0.015625,  0.746094,  2.003906,  0.015000,  1.871094,  0.030000,  0.027500,  1.875000,  0.027500,  2.000000,  0.020750,  1.359375,  0.025938,  1.992188,  0.020250,  1.632812,  0.024844,  1.902344,  0.015000,  1.350000,  0.023750,  1.359375,  0.045000 }
  // Time:271.248610 // Laps: 2 // Avg:78.037631
  ,{ "barcelon.trk", 1, 36.645508,  1.257109,  0.350000,  4.986329, 12.781250, 19.523438,  5.063477,  5.717773,  0.976563,  0.030000,  2.015625, 31.250000,  0.435644,  0.020507,  1.960938,  1.998047,  0.016719,  1.720703,  0.030000,  0.030000,  2.000000,  0.015000,  1.015625,  0.056609,  1.593750,  0.030625,  1.740234,  0.015250,  1.539062,  0.037579,  1.671875,  0.015000,  1.240625,  0.045781,  2.257813,  0.030000 }
  // Time:216.306000 // Laps: 2 // Avg:81.735940
  // ,{ "brands.trk", 1, 34.023438,  0.976250,  0.221875,  6.093750, 13.968750, 21.687500,  5.062500,  5.750000, 78.125000,  0.027657,  1.179688, 29.687500,  0.300000,  0.017969,  1.992188,  2.000000,  0.015000,  2.000000,  0.030000,  0.027500,  2.125000,  0.015782,  1.906250,  0.029969,  1.359375,  0.030000,  2.000000,  0.015156,  4.828125,  0.026093,  1.906250,  0.015000,  2.084375,  0.017657,  2.265625,  0.026719 }
  // Time:259.518671 // Laps: 2 // Avg:75.214714
  ,{ "brazil.trk", 1, 40.217285,  1.281035,  0.350000,  4.867188, 14.250000, 12.312500,  5.304688,  6.036133,  7.995605,  0.037344,  1.740234, 84.521484,  0.300000,  0.015000,  1.398438,  2.015625,  0.015010,  1.486816,  0.030000,  0.030000,  2.000000,  0.017676,  2.000000,  0.015000,  1.237793,  0.030079,  2.000000,  0.032125,  2.260009,  0.028672,  1.765137,  0.015000,  1.894922,  0.044072,  0.500488,  0.050625 }
  //,{ "brazil.trk", 1, 40.468750,  1.329375,  0.356250,  3.765625, 13.000000, 13.125000,  5.234375,  6.089844, 175.781250,  0.030000,  1.984375, 30.078125,  0.300000,  0.015469,  1.960938,  2.000000,  0.015000,  1.750000,  0.030000,  0.030000,  2.000000,  0.018750,  1.968750,  0.015000,  1.031250,  0.053516,  2.000000,  0.024781,  3.345702,  0.024219,  1.796875,  0.015000,  1.896875,  0.039375,  0.937500,  0.061719 }
  // Time:145.021947 // Laps: 2 // Avg:91.231679
  // ,{ "cstlcomb.trk", 1, 40.996094,  1.375468,  0.362500,  7.078125,  6.734375, 12.593750,  5.421875,  5.933594,  3.906250,  0.029376,  2.000000, 25.000000,  0.300000,  0.023516,  1.199219,  2.000000,  0.015547,  1.484375,  0.030000,  0.027500,  1.875000,  0.027579,  2.089844,  0.032000,  2.031250,  0.030000,  2.000000,  0.030016,  4.121093,  0.025469,  1.945313,  0.015000,  1.619531,  0.030000,  2.000000,  0.030000 }
  // Time:240.848945 // Laps: 2 // Avg:80.923906
  ,{ "estoril.trk", 1, 39.941406,  1.452422,  0.382812,  4.746094, 13.210937, 10.664062,  5.361328,  5.672852, 69.921875,  0.029688,  2.000000, -140.429688,  0.300000,  0.031016,  1.169922,  2.138672,  0.025000,  1.646485,  0.030000,  0.030000,  2.000000,  0.015000,  1.796875,  0.020312,  1.806641,  0.030000,  2.000000,  0.032632,  1.750000,  0.023008,  1.917968,  0.015156,  1.834375,  0.030000,  2.000000,  0.030000 }
  // Time:313.127214 // Laps: 2 // Avg:93.841026
  ,{ "hock.trk", 1, 46.428711,  0.934063,  0.067969,  8.559375, 11.437500,  7.437500,  5.046875,  6.815918, 362.066406,  0.071758,  2.000000, 169.238282,  0.300000,  0.017636,  1.783204,  2.000000,  0.015000,  1.828125,  0.030000,  0.030000,  2.000000,  0.015000,  1.218750,  0.031062,  1.656250,  0.028438,  1.093750,  0.015000,  1.718749,  0.017344,  1.203125,  0.015000,  1.615625,  0.030000,  2.000000,  0.030000 }
  // Time:247.708800 // Laps: 2 // Avg:71.897152
  ,{ "hungary.trk", 1, 42.744141,  1.327227,  0.350000,  6.369141,  7.750000, 13.000000,  5.347656,  5.902344, 56.933594,  0.033242,  1.886719, 281.835938,  0.300000,  0.015195,  1.455079,  2.000000,  0.015879,  1.550781,  0.030000,  0.030000,  2.000000,  0.015000,  1.613281,  0.030125,  2.015625,  0.030000,  2.000000,  0.023082,  3.181640,  0.025879,  1.925781,  0.015000,  1.920312,  0.019102,  1.879883,  0.030000 }
  // Time:244.575094 // Laps: 2 // Avg:77.984742
  ,{ "magnycrs.trk", 1, 36.845703,  1.182500,  0.290625,  8.531250, 18.906250, 18.468750,  5.024414,  6.078125, 79.980469,  0.034688,  1.203125, 29.687500,  0.368652,  0.026621,  1.945314,  1.789063,  0.037188,  1.539062,  0.030000,  0.030000,  2.000000,  0.019766,  1.566406,  0.023094,  1.687500,  0.030333,  1.805664,  0.021656,  1.718749,  0.026875,  1.843750,  0.015000,  1.283594,  0.027188,  1.671875,  0.029375 }
  // Time:111.955442 // Laps: 1 // Avg:59.457658
  // ,{ "monaco.trk", 1, 44.882813,  1.192656,  0.221875,  6.121094, 14.312500, 19.695313,  5.000000,  6.726563, 68.945313,  0.026875,  1.669922, 51.757813,  0.300000,  0.015078,  1.464844,  1.312500,  0.019687,  1.109376,  0.030000,  0.030000,  2.000000,  0.015000,  1.658203,  0.053711,  2.015625,  0.015117,  2.011719,  0.031031,  0.500000,  0.022071,  1.324219,  0.015000,  1.068750,  0.025469,  1.697266,  0.017500 }
  // Time:236.211299 // Laps: 2 // Avg:83.940135
  // ,{ "montreal.trk", 1, 46.274415,  1.338164,  0.350000,  6.937500, 15.906250, 22.125000,  5.044922,  6.980469, 74.902344,  0.015156,  2.191406, 29.687500,  0.300000,  0.015312,  1.386719,  2.060547,  0.021406,  2.000000,  0.030000,  0.030000,  2.000000,  0.015000,  1.570313,  0.037508,  1.992188,  0.036172,  1.937500,  0.023219,  1.390624,  0.024219,  1.781250,  0.015000,  1.975000,  0.020000,  2.121094,  0.029883 }
  // Time:281.391103 // Laps: 2 // Avg:92.205628
  ,{ "monza-76.trk", 1, 45.410156,  1.473906,  0.200000,  5.773438, 13.007812, 21.250000,  4.320312,  5.550781,  0.976562,  0.018320,  1.085937, 29.687500,  0.300000,  0.025313,  0.523438,  2.046875,  0.020469,  2.351562,  0.030000,  0.030000,  2.000000,  0.015156,  2.035156,  0.028875,  1.298828,  0.030000,  2.000000,  0.044039,  3.570312,  0.025469,  4.031250,  0.015156,  1.998437,  0.015000,  1.507812,  0.023438 }
  // Time:210.047400 // Laps: 2 // Avg:85.753339
  ,{ "mosport.trk", 1, 22.114868,  1.519267,  0.284375,  5.453125,  9.062500,  8.500000,  5.054688,  6.203125, 112.011719,  0.030000,  2.000000, 30.078125,  0.300000,  0.027969,  1.867188,  2.000000,  0.015000,  2.000000,  0.030000,  0.030000,  2.000000,  0.015000,  1.000000,  0.022000,  1.148438,  0.030000,  2.000000,  0.025875,  1.585937,  0.023985,  1.937500,  0.015000,  2.021875,  0.030000,  2.000000,  0.030000 }
  //,{ "mosport.trk", 1, 22.031250,  1.521953,  0.284375,  5.453125,  9.062500,  8.500000,  5.054688,  6.203125, 112.109375,  0.030000,  2.000000, 30.078125,  0.300000,  0.027969,  1.867188,  2.000000,  0.015000,  2.000000,  0.030000,  0.030000,  2.000000,  0.015000,  1.000000,  0.022000,  1.148438,  0.030000,  2.000000,  0.025875,  1.585937,  0.023985,  1.937500,  0.015000,  2.021875,  0.030000,  2.000000,  0.030000 }
  // Time:242.665867 // Laps: 2 // Avg:83.737878
  ,{ "nurburg.trk", 1, 40.478516,  1.476445,  0.259375,  6.328125, 16.140625, 15.750000,  5.531250,  5.320313, 40.917969,  0.030937,  1.890625, 29.687500,  0.300000,  0.015000,  1.984376,  1.593750,  0.015000,  1.812500,  0.030000,  0.030000,  2.000000,  0.030000,  2.000000,  0.022039,  1.080078,  0.030000,  2.000000,  0.033610,  2.249998,  0.025860,  1.625000,  0.022031,  1.693750,  0.016250,  1.265625,  0.051250 }
  // Time:88.773300 // Laps: 3 // Avg:71.081468
  ,{ "oval2.trk", 1, 40.390625,  1.523125,  0.178125, -7.984375, 18.406250,  3.687500,  5.351563,  6.250000, 88.281250,  0.033125,  2.000000, 50.000000,  0.300000,  0.030000,  2.000001,  2.000000,  0.017656,  2.000000,  0.030000,  0.027500,  2.125000,  0.032500,  2.000000,  0.032000,  2.031250,  0.030000,  2.000000,  0.031500,  1.851562,  0.030000,  2.101563,  0.018125,  2.068750,  0.030000,  2.000000,  0.030000 }
  // Time:268.351200 // Laps: 3 // Avg:100.527384
  ,{ "pocono.trk", 1, 42.949219,  1.143828,  0.343750,  1.203125, 12.726563,  4.218750,  5.601563,  6.187500, 134.179688,  0.038047,  2.000000, 25.000000,  0.300000,  0.015000,  1.312501,  1.972656,  0.015391,  1.726563,  0.030000,  0.030000,  2.000000,  0.030000,  2.000000,  0.029500,  2.031250,  0.030000,  2.000000,  0.029000,  1.976562,  0.022422,  1.710938,  0.015000,  1.920312,  0.030000,  2.000000,  0.030000 }
  // Time:274.115700 // Laps: 2 // Avg:83.761280
  ,{ "silverst.trk", 1, 45.444336,  1.522344,  0.198437,  4.054688, 13.171875, 14.281250,  5.109375,  5.726563, 50.000000,  0.029844,  2.000000, 29.687500,  0.300000,  0.015000,  2.078126,  2.000000,  0.015156,  2.015625,  0.030000,  0.030000,  2.000000,  0.020000,  1.550781,  0.015000,  1.039063,  0.030000,  2.000000,  0.015000,  1.109374,  0.020156,  1.734375,  0.015000,  1.818750,  0.020000,  1.810547,  0.016094 }
  // Time:363.426617 // Laps: 2 // Avg:84.989964
  ,{ "spa.trk", 1, 36.962891,  1.396953,  0.143750,  5.000000,  7.156250,  7.820313,  5.308594,  5.917969, 86.914063,  0.055273,  2.109375, 168.652344,  0.300000,  0.015156,  1.830079,  0.515625,  0.024219,  2.335938,  0.030000,  0.030000,  2.000000,  0.015000,  2.509766,  0.017000,  2.062500,  0.030000,  2.000000,  0.024000,  2.117187,  0.022969,  2.656250,  0.015000,  2.100977,  0.020937,  2.011719,  0.031250 }
  // Time:250.179300 // Laps: 3 // Avg:93.859139
  //,{ "speed2.trk", 1, 52.031250,  1.223125,  0.406250,  9.562500,  5.546875, 20.812500,  5.097656,  8.156250, 261.328125,  0.028047,  2.000000, 25.000000,  0.300000,  0.015000,  2.000001,  2.000000,  0.015000,  1.679688,  0.030000,  0.027500,  2.125000,  0.015000,  1.820313,  0.032000,  2.031250,  0.030000,  2.000000,  0.015000,  5.734374,  0.026250,  1.906250,  0.015000,  2.764062,  0.030000,  2.000000,  0.030000 }
  // Time:310.788900 // Laps: 2 // Avg:84.868138
  ,{ "suzuka.trk", 1, 41.987305,  1.376250,  0.327344,  5.343750, 13.000000, 20.625000,  4.839844,  6.148438, 50.000000,  0.070000,  1.328125, 345.312500,  0.300000,  0.015000,  2.960938,  2.000000,  0.015000,  2.000000,  0.030000,  0.030000,  2.000000,  0.015000,  2.000000,  0.031531,  1.406250,  0.035000,  2.000000,  0.021500,  2.562499,  0.024219,  1.906250,  0.015000,  2.100000,  0.015000,  1.597656,  0.025000 }
  // Time:249.849900 // Laps: 2 // Avg:76.365844
  // ,{ "tremblnt.trk", 1, 16.286622,  1.487773,  0.331250,  7.545898, 12.093750, 23.031250,  5.242676,  6.062500,  8.593750,  0.058965,  2.000000, 30.468750,  0.300000,  0.015625,  2.021485,  2.000000,  0.027031,  2.968750,  0.030000,  0.030000,  2.000000,  0.015000,  2.433594,  0.025517,  1.441407,  0.030000,  2.000000,  0.015000,  2.890624,  0.035312,  1.921875,  0.015000,  1.998438,  0.030000,  2.000000,  0.030000 }
  // Time:246.830400 // Laps: 2 // Avg:77.300035
  // ,{ "tremblnt.trk", 1, 17.927247,  1.078398,  0.331250,  4.670898, 12.031250, 23.031250,  5.211426,  6.062500, 107.031250,  0.038340,  2.000000, 13.281250,  0.300000,  0.015625,  2.021485,  2.000000,  0.027031,  2.968750,  0.030000,  0.030000,  2.000000,  0.015000,  2.433594,  0.025517,  1.441407,  0.030000,  2.000000,  0.015000,  2.890624,  0.035312,  1.921875,  0.015000,  1.998438,  0.030000,  2.000000,  0.030000 }
  // Time:104.310000 // Laps: 2 // Avg:64.558659
  ,{ "v03.trk", 1, 46.367188,  1.134063,  0.337500,  6.937500, 23.625000, 23.687500,  5.449219,  6.250000, 100.000000,  0.018594,  2.242188, 50.000000,  0.300000,  0.026719,  1.992188,  2.000000,  0.015313,  2.000000,  0.030000,  0.027500,  2.125000,  0.021719,  1.945313,  0.032000,  2.031250,  0.030000,  2.000000,  0.031500,  1.851562,  0.030000,  2.000000,  0.015000,  1.998437,  0.025000,  1.140625,  0.045937 }
  // Time:284.931000 // Laps: 2 // Avg:87.796131
  //,{ "watglen.trk", 1, 48.315430,  1.235820,  0.342969,  2.285156,  8.281250, 20.796875,  5.300781,  6.608887,  0.976563,  0.042969,  2.000000, 30.078125,  0.300000,  0.026250,  1.339844,  2.000000,  0.020078,  2.015625,  0.030000,  0.030000,  2.000000,  0.030000,  2.000000,  0.015000,  0.937500,  0.030000,  2.000000,  0.023437,  3.707030,  0.015391,  1.492188,  0.015000,  1.857812,  0.030000,  2.000000,  0.030000 }
  // Time:216.031500 // Laps: 2 // Avg:85.057519
  ,{ "zandvort.trk", 1, 38.222656,  0.786797,  0.022852,  6.750000, 11.035156, 19.925781,  4.893555,  6.250000, 100.000000,  0.030000,  2.000000, 29.687500,  0.300000,  0.030000,  1.500978,  2.000000,  0.015547,  2.000000,  0.030000,  0.030000,  2.000000,  0.015664,  1.628906,  0.022156,  1.158203,  0.030000,  2.000000,  0.031637,  3.046874,  0.017969,  1.691406,  0.015000,  1.678125,  0.030000,  2.000000,  0.030000 }

  ,{ "", -1 }
};

// speed, alpha optimization
static T_speed sdata[] =
{
  // Time: 117.980100 // Laps: 1
  { "adelaid2.trk", 1, { {345.156250,274.843750}, {132.698775,143.480025}, {162.404588,174.748338}, {320.000000,319.531250}, {139.495260,198.080900}, {361.406250,311.250000}, {99.841083,82.966083}, {321.250000,320.000000}, {144.118461,80.368461}, {320.000000,320.000000}, {144.216083,82.653583}, {320.000000,320.000000}, {98.577910,130.765410}, {108.772739,113.460239}, {260.000000,295.937500}, {100.268951,92.143951}, {299.687500,261.093750}, {151.417858,187.355358}, {262.968750,285.468750}, {100.128975,61.066475}, {260.000000,260.000000}, {113.879925,112.786175}, {99.908294,67.408294}, {100.911175,151.677594}, {265.312500,264.062500}, {134.584987,154.980566},
  {260.000000,252.812500}, {100.104905,66.667405}}
  , 46, { {0.015000,1.164063}, {0.026406,0.984375}, {0.019844,1.578125}, {0.015000,1.890625}, {0.015000,0.500000}, {0.015000,2.000000}, {0.022515,3.210937}, {0.015000,2.006250}, {0.048719,1.554688}, {0.033281,1.546875}, {0.015000,2.006250}, {0.038172,1.304688}, {0.034531,1.937500}, {0.015000,1.678125}, {0.029969,1.273438}, {0.030860,1.531250}, {0.015000,1.615625}, {0.023797,1.136719}, {0.029999,2.000000}, {0.022578,1.578125}, {0.015000,2.000000}, {0.015000,0.500000}, {0.045938,1.640625}, {0.043281,1.906250}, {0.024688,1.631250}, {0.020156,1.796875}, {0.030000,1.851563}, {0.036875,2.000000}, {0.030469,1.953125}, {0.030000,1.998438}, {0.030001,2.000000},
  {0.030000,1.992188}, {0.047813,2.003906}, {0.030000,0.992188}, {0.030001,1.299219}, {0.030001,2.000000}, {0.030000,2.000001}, {0.030016,0.738281}, {0.030000,1.998438}, {0.017344,2.000000}, {0.030000,2.000001}, {0.022047,1.792968}, {0.015000,1.803125}, {0.042187,1.539062}, {0.034219,1.640625}, {0.030000,1.631250}}
  ,{ 2.130859, 4.755859, 7.505859, 6.255859, 3.625000, 1.125000, 1.000000, 4.505859, 1.000000, 7.537109, 4.312500, 5.005859, 3.880859, 7.005859, 5.005859, 1.375000}
  ,{ 45,  0,  2,  4,  5,  7,  8, 10, 11, 13, 14, 16, 17, 19, 21, 22, 24, 27, 29, 32, 34, 36, 37, 37, 38, 40, 42, 43} }

  // Time: 106.506000 // Laps: 1
  ,{ "brands.trk", 1, { {351.250000,288.125000}, {100.122205,63.533943}, {217.500000,288.437500}, {100.281728,78.035166}, {100.011084,105.117271}, {200.000000,239.375000}, {99.411101,145.251895}, {99.878370,90.225173}, {160.625000,200.000000}, {90.473299,236.306238}, {200.000000,200.000000}, {100.085915,133.432536}, {200.000000,200.000000}, {107.303260,150.379548}, {200.000000,200.000000}, {117.025843,142.001393}, {200.000000,200.000000}, {104.378777,146.688933}, {200.000000,280.000000}, {91.437732,131.569963}, {87.829638,133.900303}, {113.282577,137.135887}, {240.000000,283.750000}, {100.043987,85.249314}, {315.625000,236.250000}, {99.392828,130.573444},
  {100.052595,123.816072}, {240.000000,240.000000}, {139.431696,181.541442}, {99.788944,104.659228}, {240.000000,240.000000}, {114.909206,215.705202}}
  , 57, { {0.015782,1.906250}, {0.026093,1.906250}, {0.037500,2.084375}, {0.027500,1.390625}, {0.029969,1.359375}, {0.034530,2.000000}, {0.033281,4.828125}, {0.015313,2.084375}, {0.035000,2.000000}, {0.028282,1.992188}, {0.027657,2.000000}, {0.028906,1.906250}, {0.015469,1.578125}, {0.015000,2.084375}, {0.015000,2.500000}, {0.029969,1.359375}, {0.026093,1.921875}, {0.015000,2.084375}, {0.016875,2.000000}, {0.029844,1.992188}, {0.028282,2.000000}, {0.026093,1.906250}, {0.026250,2.084375}, {0.017188,1.890625}, {0.018594,1.992188}, {0.030157,2.000000}, {0.026093,1.906250}, {0.015000,2.068750}, {0.015782,1.906250}, {0.031093,1.921875}, {0.017500,1.975000},
  {0.022032,1.906250}, {0.026718,2.000000}, {0.015625,2.006250}, {0.021407,1.921875}, {0.026718,1.937500}, {0.019219,1.179688}, {0.017657,2.140625}, {0.029844,1.492188}, {0.017969,2.000000}, {0.015000,2.006250}, {0.029969,1.140625}, {0.029531,1.906250}, {0.020625,2.053125}, {0.029969,2.000000}, {0.027656,1.453125}, {0.030156,2.000000}, {0.030000,2.006250}, {0.030000,2.000000}, {0.029844,1.992188}, {0.029844,2.000000}, {0.030156,2.000000}, {0.030156,2.828125}, {0.023125,2.006250}, {0.020782,1.906250}, {0.030156,2.000000}, {0.030000,2.006250}}
  ,{ 1.000000, 5.093750, 8.093750, 5.968750, 4.718750, 8.593750, 5.468750, 5.593750, 6.281250, 5.156250, 5.906250, 6.031250, 13.031250, 1.000000, 4.968750, 14.406250, 4.968750, 4.968750, 9.843750}
  ,{ 56,  0,  2,  4,  6,  7, 10, 12, 13, 15, 17, 20, 22, 25, 27, 28, 30, 31, 33, 34, 36, 38, 40, 41, 43, 44, 46, 47, 50, 52, 53, 54} }

  // Time: 391.107600 // Laps: 3
  ,{ "buenos.trk", 1, { {189.687500,242.343750}, {69.069149,101.525625}, {99.882337,77.971296}, {100.000000,114.375000}, {101.127725,122.690225}, {148.750000,148.750000}, {99.988494,68.738494}, {124.375000,139.375000}, {100.029093,106.591593}, {97.491180,120.147430}, {123.750000,136.250000}, {97.522602,99.085102}, {170.625000,150.000000}, {100.028193,147.528193}, {159.375000,168.750000}, {75.443418,73.099668}, {100.000000,100.000000}, {98.812789,101.536132}, {104.034437,110.440687}, {100.000000,114.375000}, {99.999203,99.061703}, {101.250000,110.625000}, {100.037284,81.287284}, {143.125000,135.625000}, {99.829130,64.829130}, {100.000000,100.000000},
  {100.252982,62.550350}, {100.000000,100.000000}, {96.087845,99.994095}, {177.500000,150.000000}, {100.069916,89.132416}, {299.375000,211.875000}, {117.976310,134.851310}}
  , 64, { {0.021844,1.459960}, {0.027813,1.417969}, {0.029532,3.750977}, {0.020703,2.006250}, {0.030548,1.896484}, {0.030001,1.890625}, {0.020938,2.060937}, {0.029968,1.932617}, {0.027188,1.492188}, {0.030000,2.060937}, {0.027929,1.781251}, {0.030000,2.000001}, {0.069063,2.000000}, {0.029532,1.359375}, {0.030117,1.949218}, {0.028398,1.998047}, {0.031250,1.998437}, {0.055626,0.896484}, {0.016406,0.562500}, {0.018984,2.338281}, {0.026288,1.660157}, {0.035860,1.515626}, {0.070157,2.000000}, {0.024688,1.402344}, {0.025781,2.100000}, {0.019063,1.945313}, {0.034218,3.296876}, {0.070704,2.000000}, {0.025079,1.675781}, {0.015000,2.100000}, {0.022929,1.617188},
  {0.030391,2.000001}, {0.016251,3.282227}, {0.028007,1.492187}, {0.020352,1.998047}, {0.019218,1.975000}, {0.029258,2.000001}, {0.056797,1.059570}, {0.030001,1.367188}, {0.019375,0.975000}, {0.030038,1.781251}, {0.029922,2.015626}, {0.070313,2.000000}, {0.027344,1.429688}, {0.030000,1.842187}, {0.030038,2.000001}, {0.030000,2.000001}, {0.096251,0.500000}, {0.030001,1.070313}, {0.034609,1.998437}, {0.017617,1.789063}, {0.044375,1.985352}, {0.023985,1.209375}, {0.015000,1.283203}, {0.029688,1.687500}, {0.030000,1.857812}, {0.024570,1.816407}, {0.030000,2.128907}, {0.053282,2.000000}, {0.029844,1.359375}, {0.016406,2.107812}, {0.015000,1.428710},
  {0.030001,2.000000}, {0.030000,1.998437}}
  ,{ 12.203125, 24.718750, 9.093750, 1.000000, 1.000000, 20.406250, 1.000000, 4.156250, 1.000000, 10.218750, 4.843750, 5.500000, 1.250000, 6.312500, 6.968750, 5.000000, 1.000000, 3.984375}
  ,{ 63,  0,  2,  3,  4,  6,  7,  9, 12, 14, 16, 17, 19, 22, 24, 27, 29, 31, 33, 35, 37, 39, 42, 44, 47, 49, 50, 52, 53, 55, 58, 60, 61} }

  // Time: 73.730700 // Laps: 1
  ,{ "cstlcomb.trk", 1, { {375.156250,305.468750}, {98.295001,152.843062}, {258.125000,247.812500}, {98.940432,196.817716}, {180.000000,379.375000}, {95.657655,118.089408}, {140.625000,179.375000}, {99.915530,80.137109}, {175.468750,256.093750}, {101.599260,168.532236}, {196.093750,180.000000}, {98.922181,170.570876}, {180.000000,200.000000}, {113.651652,115.995402}, {100.359884,100.047384}, {101.960118,106.893453}, {250.000000,199.062500}, {96.236621,168.254699}, {182.968750,181.250000}, {99.990278,127.330685}}
  , 39, { {0.019453,2.039063}, {0.028594,1.300782}, {0.030391,1.945313}, {0.025234,1.914063}, {0.015000,1.709375}, {0.044610,4.632813}, {0.030547,1.984375}, {0.028516,1.949219}, {0.029376,2.000000}, {0.025782,1.957032}, {0.015000,1.642969}, {0.055312,0.640625}, {0.030953,4.730468}, {0.015938,1.424219}, {0.027813,1.531250}, {0.030328,1.523437}, {0.021563,1.924219}, {0.029375,2.089844}, {0.030078,1.300782}, {0.029454,2.011719}, {0.029297,2.000001}, {0.015000,0.500000}, {0.015313,1.734375}, {0.029969,2.000000}, {0.030000,2.000001}, {0.015078,1.998437}, {0.028203,2.000000}, {0.030016,3.042968}, {0.015000,0.578125}, {0.015000,0.527344}, {0.030000,1.808594},
  {0.030001,2.000000}, {0.030000,2.000001}, {0.020235,1.998437}, {0.015859,2.000000}, {0.030000,1.214844}, {0.044064,2.000000}, {0.030000,1.613282}, {0.015703,0.767969}}
  ,{ 18.687500, 1.312500, 3.000000, 2.125000, 4.953125, 5.015625, 16.140625, 1.562500, 17.015625, 12.453125, 8.046875}
  ,{ 38,  2,  4,  8, 10, 11, 13, 14, 16, 19, 21, 23, 25, 26, 27, 27, 28, 31, 33, 36} }

  // Time: 141.147900 // Laps: 1
  ,{ "imola.trk", 1, { {358.046875,363.046875}, {98.823998,170.777123}, {180.625000,331.562500}, {99.407567,91.282567}, {99.967386,84.967386}, {170.000000,230.703125}, {100.029449,114.091949}, {204.531250,249.296875}, {100.129955,145.129955}, {100.035616,109.410616}, {249.062500,265.234375}, {65.626014,69.376014}, {370.546875,409.375000}, {99.956588,157.065963}, {170.000000,337.031250}, {99.934564,73.840814}, {308.359375,290.000000}, {97.729332,188.354332}, {318.437500,354.375000}, {105.711388,120.711388}, {170.000000,350.625000}, {100.100424,75.725424}, {454.375000,446.953125}, {97.507749,196.882749}, {302.968750,502.187500}, {101.835150,98.710150},
  {99.928142,85.240642}, {237.500000,218.125000}, {121.737481,140.331231}, {298.721153,295.190383}, {98.861036,207.172848}, {170.000000,286.562500}, {100.084901,77.741151}, {170.000000,290.000000}, {100.148129,86.398129}, {219.531250,349.062500}, {117.678103,143.068728}, {170.000000,181.718750}, {100.129576,99.973326}, {170.000000,170.000000}, {100.029056,102.216556}}
  , 69, { {0.019375,1.453125}, {0.030000,1.656250}, {0.032148,0.631250}, {0.016758,1.707031}, {0.021016,2.380860}, {0.030000,1.250000}, {0.064610,1.613281}, {0.030000,1.767578}, {0.026992,1.722656}, {0.015000,0.678125}, {0.019375,1.486328}, {0.024688,1.552734}, {0.015000,0.615625}, {0.015000,0.703125}, {0.025039,2.367188}, {0.030000,2.000000}, {0.029766,1.701172}, {0.030000,1.734375}, {0.026875,1.660156}, {0.015000,0.617578}, {0.019375,1.484375}, {0.024688,0.500000}, {0.015312,0.553125}, {0.019375,1.470703}, {0.026250,1.562500}, {0.015430,0.615625}, {0.019414,1.468750}, {0.024844,1.558593}, {0.015312,0.615625}, {0.017500,1.335938}, {0.024961,1.525390},
  {0.017891,0.633203}, {0.019375,2.402344}, {0.020586,0.736328}, {0.018125,2.000391}, {0.027852,1.347657}, {0.027891,1.591797}, {0.015234,0.639063}, {0.020352,1.468750}, {0.025313,1.550781}, {0.015039,0.615625}, {0.020156,0.972656}, {0.019844,1.675781}, {0.039062,0.539063}, {0.030000,1.300781}, {0.015000,0.631250}, {0.015234,2.175781}, {0.028047,2.039063}, {0.030000,2.000000}, {0.034062,1.570312}, {0.030001,3.023438}, {0.030000,2.003906}, {0.021953,1.886718}, {0.016875,0.803125}, {0.019999,1.468750}, {0.031563,1.957031}, {0.015000,0.615625}, {0.019844,0.792969}, {0.030001,1.246093}, {0.020156,0.574219}, {0.023750,1.609375}, {0.030000,1.984375},
  {0.030001,1.584375}, {0.030000,1.632813}, {0.030000,2.003906}, {0.017500,0.664063}, {0.020314,1.675781}, {0.029688,1.703125}, {0.015000,0.615625}}
  ,{ 15.046875, 7.484375, 5.859375, 5.109375, 4.671875, 2.859375, 1.000000, 9.765625, 1.250000, 14.546875, 7.734375, 7.796875, 7.859375, 7.859375, 7.453125, 13.234375, 7.765625, 12.609375, 3.421875, 7.140625, 5.109375, 5.000000, 6.359375}
  ,{ 68,  0,  2,  5,  7,  9, 10, 12, 15, 17, 19, 20, 22, 23, 25, 26, 28, 29, 31, 32, 34, 35, 37, 38, 40, 41, 43, 45, 48, 50, 52, 53, 54, 56, 57, 59, 60, 62, 63, 65, 66} }

  // Time: 110.846349 // Laps: 1
  ,{ "monaco.trk", 1, { {402.812500,409.375000}, {100.180316,52.647527}, {359.531250,371.640625}, {250.447361,276.706556}, {250.000000,353.984375}, {100.208085,42.937908}, {250.000000,444.765625}, {30.913731,68.746706}, {250.000000,409.296875}, {97.829925,60.392562}, {383.437500,399.765625}, {101.358840,148.966014}, {400.703125,407.500000}, {11.250000,68.746706}, {359.218750,435.625000}, {100.913731,12.279878}, {250.000000,220.937500}, {99.896914,153.226975}, {399.687500,374.375000}, {100.913731,99.995514}, {250.000000,400.000000}, {100.142803,83.951315}, {250.000000,350.546875}, {98.913996,97.310566}, {250.000000,250.000000}, {97.697589,158.568858},
  {250.000000,250.000000}, {101.203124,115.388443}, {250.000000,250.000000}, {99.793698,94.621739}, {250.000000,345.312500}, {98.965413,115.890409}, {100.274638,51.909731}, {330.000000,320.156250}, {100.271245,61.319259}, {98.689742,99.966675}, {350.034314,235.217788}, {99.696965,59.224974}, {250.000000,263.593750}, {98.708014,218.101819}, {169.761193,144.343554}, {250.000000,250.000000}, {100.382608,73.175510}, {250.000000,250.000000}, {100.190527,99.967564}}
  , 78, { {0.015000,1.195313}, {0.015000,3.152344}, {0.015000,0.500000}, {0.022071,1.167969}, {0.015000,1.100000}, {0.015000,3.003906}, {0.030000,2.000000}, {0.024883,2.076172}, {0.015000,1.810938}, {0.015469,1.658203}, {0.022071,1.386719}, {0.015000,1.068750}, {0.019687,1.109376}, {0.030078,1.964844}, {0.031031,0.500000}, {0.015000,1.068750}, {0.015000,1.658203}, {0.022071,1.324219}, {0.035000,1.068750}, {0.019804,1.093751}, {0.015078,1.714844}, {0.017500,1.343750}, {0.051759,0.500000}, {0.015000,3.053125}, {0.063711,2.015625}, {0.022071,1.402344}, {0.015312,1.068750}, {0.019687,1.109376}, {0.031031,0.500000}, {0.015000,1.068750}, {0.015000,1.658203},
  {0.022071,1.324219}, {0.015000,1.068750}, {0.019687,1.109376}, {0.031031,2.000000}, {0.020000,1.076563}, {0.015000,1.658203}, {0.022071,1.363282}, {0.015000,1.068750}, {0.015000,1.658203}, {0.022305,1.351563}, {0.015000,1.068750}, {0.015117,2.000000}, {0.022071,1.324219}, {0.015000,1.076563}, {0.015000,1.658203}, {0.022071,1.347657}, {0.015000,1.068750}, {0.015117,2.011719}, {0.022071,1.824219}, {0.015000,1.146875}, {0.015000,1.673828}, {0.022696,0.839844}, {0.028125,1.685547}, {0.026172,1.712891}, {0.015000,1.115625}, {0.022499,1.140626}, {0.015078,1.464844}, {0.028125,1.312500}, {0.022071,1.339844}, {0.028437,1.669922}, {0.025469,1.697266},
  {0.030625,1.701172}, {0.026719,1.728516}, {0.059781,0.703125}, {0.015000,0.600000}, {0.015000,1.117188}, {0.030078,1.964844}, {0.030093,2.480469}, {0.030000,1.998047}, {0.030000,1.994141}, {0.015000,1.998438}, {0.024218,1.109376}, {0.030015,1.910156}, {0.018516,2.115625}, {0.022499,1.183595}, {0.031031,1.320313}, {0.015078,1.068750}}
  ,{ 1.000000, 8.902344, 6.121094, 6.121094, 6.121094, 6.121094, 6.746094, 6.433594, 6.121094, 6.121094, 6.121094, 5.058594, 1.031250, 1.281250, 5.589844, 7.996094, 5.121094, 5.996094, 5.371094, 9.902344, 7.777344, 10.714844, 4.933594, 4.996094, 3.761719}
  ,{ 77,  2,  4,  6,  8,  9, 11, 13, 15, 16, 18, 21, 23, 24, 26, 27, 29, 30, 32, 33, 35, 36, 38, 39, 41, 42, 44, 45, 47, 48, 50, 51, 53, 55, 58, 60, 62, 64, 65, 67, 69, 71, 72, 74, 75} }

  // Time: 227.862631 // Laps: 2
  ,{ "montreal.trk", 1, { {538.125000,346.562500}, {121.023567,172.826789}, {461.562500,490.625000}, {88.949841,99.255379}, {200.000000,200.000000}, {103.780608,115.712781}, {373.437500,240.000000}, {823.138791,872.009471}, {396.250000,384.375000}, {293.106386,444.569513}, {200.000000,400.625000}, {104.891529,121.584055}, {200.000000,200.000000}, {107.009564,130.232332}, {403.437500,489.062500}, {647.114503,824.655969}, {401.250000,342.500000}, {301.448005,439.172342}, {200.000000,409.375000}, {76.413809,54.993117}, {411.875000,336.875000}, {98.949841,141.394646}, {104.356061,206.445362}, {395.625000,312.500000}, {90.552805,205.348813}, {180.252696,141.253534},
  {118.921567,353.821349}, {401.562500,431.875000}, {104.757642,185.496718}, {200.000000,200.000000}, {136.248761,151.333781}, {400.000000,421.250000}, {152.704029,208.407660}, {200.000000,200.000000}, {113.590339,117.241770}, {200.000000,257.187500}, {58.709645,56.209645}, {100.048204,173.841439}, {200.000000,381.875000}, {100.380113,117.232757}, {120.942521,153.373066}}
  , 67, { {0.015000,2.000000}, {0.025312,1.886719}, {0.023219,2.406249}, {0.015000,1.975000}, {0.021406,1.625000}, {0.023219,1.390624}, {0.015000,1.975000}, {0.036172,1.937500}, {0.024219,1.781250}, {0.015000,1.975000}, {0.015000,1.570313}, {0.024219,1.781250}, {0.015000,1.990625}, {0.015000,1.570313}, {0.024219,1.781250}, {0.015000,1.975000}, {0.015000,1.570313}, {0.024219,1.835938}, {0.015000,1.975000}, {0.029922,2.000000}, {0.024219,1.781250}, {0.015000,1.975000}, {0.015000,1.570313}, {0.024219,1.781250}, {0.015000,1.975000}, {0.015000,1.570313}, {0.024219,1.781250}, {0.015000,2.514063}, {0.021406,2.000000}, {0.036172,1.937500}, {0.024219,1.781250},
  {0.015000,0.787500}, {0.021719,2.000000}, {0.017812,1.386719}, {0.023219,1.390624}, {0.029883,2.191406}, {0.025000,2.121094}, {0.015000,1.975000}, {0.015000,1.570313}, {0.024219,1.781250}, {0.029883,2.207031}, {0.020000,1.761719}, {0.029883,2.207031}, {0.020000,2.121094}, {0.015313,1.975000}, {0.021406,2.000000}, {0.015312,1.386719}, {0.015156,2.060547}, {0.029844,2.000000}, {0.015000,1.975000}, {0.036172,1.937500}, {0.024219,1.781250}, {0.015000,1.975000}, {0.036883,1.992188}, {0.029219,1.781250}, {0.015000,1.975000}, {0.036172,1.968750}, {0.024219,1.781250}, {0.015000,1.975000}, {0.060781,2.000000}, {0.050094,1.390624}, {0.015000,1.975000},
  {0.015000,1.570313}, {0.024219,1.781250}, {0.029883,2.191406}, {0.020000,2.121094}, {0.015625,1.975000}}
  ,{ 11.000000, 6.937500, 1.062500, 17.687500, 6.937500, 10.937500, 6.687500, 11.062500, 7.187500, 7.062500, 29.562500, 15.812500, 7.062500, 10.937500, 12.937500, 6.937500, 7.562500, 2.937500, 6.937500, 5.937500, 7.687500, 6.562500, 7.312500}
  ,{ 66,  1,  3,  4,  6,  7,  9, 10, 12, 13, 15, 16, 18, 19, 21, 22, 24, 25, 27, 29, 31, 33, 35, 37, 38, 40, 42, 44, 47, 49, 50, 52, 53, 55, 56, 58, 59, 60, 61, 62, 64} }

  // Time: 165.962700 // Laps: 1
  ,{ "ra.trk", 1, { {384.062500,457.812500}, {105.441297,123.250009}, {387.812500,372.500000}, {99.926448,99.915654}, {400.000000,398.593750}, {264.482925,260.095873}, {399.375000,386.875000}, {1867.623353,2009.320366}, {396.718750,400.000000}, {188.109045,92.974637}, {317.812500,280.625000}, {100.030077,101.560757}, {277.656250,260.312500}, {261.011408,259.834684}, {338.750000,242.031250}, {99.928672,102.259670}, {260.000000,295.625000}, {123.209553,113.885984}, {245.468750,260.000000}, {259.606159,223.141043}, {260.000000,260.000000}, {259.709581,258.793025}, {260.000000,260.000000}, {207.955316,93.580533}, {234.457758,268.654033}, {260.000000,260.000000},
  {255.063918,222.054677}, {260.000000,260.000000}, {149.947854,91.481740}}
  , 53, { {0.016250,0.748535}, {0.015000,1.721680}, {0.015000,0.916016}, {0.018583,0.799805}, {0.020156,1.309473}, {0.030000,1.982910}, {0.035780,1.518555}, {0.019765,1.111328}, {0.021708,1.612305}, {0.025000,0.825098}, {0.030000,1.725097}, {0.030001,1.436524}, {0.027343,1.916016}, {0.030146,1.995118}, {0.015000,3.582911}, {0.020029,2.000000}, {0.030625,1.994141}, {0.031718,1.981348}, {0.044853,2.000000}, {0.015469,0.971680}, {0.015000,0.515625}, {0.030001,2.311035}, {0.030000,1.999024}, {0.016562,1.158203}, {0.030000,0.909180}, {0.021407,1.996973}, {0.030066,1.399414}, {0.026865,1.776368}, {0.032967,1.817286}, {0.047253,1.883789}, {0.027021,0.742188},
  {0.030000,2.075098}, {0.024206,2.227539}, {0.015000,2.795899}, {0.016875,2.395411}, {0.030000,2.049316}, {0.030000,1.663087}, {0.029999,1.998047}, {0.029990,1.913086}, {0.023672,1.938379}, {0.029987,1.977539}, {0.029990,2.002930}, {0.015156,1.973536}, {0.019909,0.500000}, {0.057021,0.500000}, {0.015000,1.216308}, {0.015468,2.000880}, {0.030078,1.998534}, {0.029996,1.997558}, {0.030000,1.996973}, {0.030065,1.297851}, {0.030145,1.721680}, {0.015312,0.515625}}
  ,{ 1.125000, 1.500000, 38.211328, 50.773828, 1.375000, 1.000000, 1.000000, 1.000000, 1.437500, 4.992578, 14.023828, 4.086328, 11.273828, 10.461328, 1.375000}
  ,{ 52,  2,  4,  7,  9, 12, 14, 16, 17, 18, 20, 23, 25, 26, 28, 29, 31, 32, 34, 37, 39, 40, 42, 43, 45, 46, 47, 49, 50} }

  // Time: 232.885800 // Laps: 3
  ,{ "speed2.trk", 1, { {399.921875,396.953125}, {316.120971,121.296290}, {400.000000,400.000000}, {388.327492,377.382555}, {400.000000,400.000000}, {404.609339,331.201800}, {383.750000,359.218750}, {125.778458,130.253848}, {400.000000,400.000000}, {393.803347,398.465584}, {400.000000,400.000000}, {268.072107,374.715584}, {393.906250,400.000000}, {288.072107,404.715584}, {390.156250,390.000000}, {288.072107,404.715584}, {390.156250,400.000000}, {313.715554,154.594062}}
  , 31, { {0.016250,2.039063}, {0.015000,2.000001}, {0.028047,2.000000}, {0.026250,1.906250}, {0.015625,2.764062}, {0.015000,1.992188}, {0.026250,2.781250}, {0.028437,1.998437}, {0.016875,1.601563}, {0.029062,2.000000}, {0.015000,1.310937}, {0.017500,1.710938}, {0.030000,2.000001}, {0.029922,2.000000}, {0.030000,2.000000}, {0.015000,2.701562}, {0.015000,3.164063}, {0.025313,4.656250}, {0.015000,3.201562}, {0.019531,1.898438}, {0.018438,4.109374}, {0.015000,1.998437}, {0.020937,1.382813}, {0.017500,5.406249}, {0.015000,1.014062}, {0.015156,0.500000}, {0.015000,4.078124}, {0.015000,1.998437}, {0.017500,2.000001}, {0.018438,2.203124}, {0.021874,1.998437} }
  ,{ 6.625000, 2.000000, 3.500000, 5.250000, 60.687500, 39.562500, 19.750000, 16.312500, 9.812500}
  ,{ 30,  2,  4,  5,  7,  8, 10, 13, 15, 16, 18, 19, 21, 22, 24, 25, 27, 28} }

  // Time: 146.473200 // Laps: 1
  ,{ "watglen.trk", 1, { {396.015625,412.890625}, {240.378899,109.267845}, {409.375000,398.125000}, {268.033221,255.505183}, {400.000000,400.000000}, {254.257914,151.560587}, {400.000000,400.000000}, {275.120075,159.058075}, {390.625000,399.062500}, {218.417949,128.912076}, {400.000000,400.000000}, {243.053789,108.189643}, {400.000000,400.000000}, {101.726680,95.471933}, {400.625000,398.750000}, {229.727492,88.338008}, {400.000000,400.000000}, {229.639765,88.038776}, {400.000000,390.625000}, {269.171519,146.576285}, {400.000000,400.000000}, {229.459969,97.407930}}
  , 44, { {0.016484,2.000000}, {0.028125,1.542969}, {0.032500,2.000000}, {0.023828,1.656251}, {0.030000,1.998437}, {0.030078,2.000000}, {0.026875,2.695313}, {0.032969,2.000000}, {0.035860,1.601563}, {0.015625,2.107812}, {0.020156,3.710938}, {0.022812,2.015625}, {0.027500,2.097655}, {0.029375,1.857812}, {0.015000,0.937500}, {0.019141,1.523438}, {0.015312,1.420312}, {0.029844,2.000000}, {0.029062,1.492188}, {0.043282,2.000000}, {0.015312,2.000001}, {0.027500,3.725000}, {0.030000,1.921875}, {0.016641,2.000001}, {0.017188,1.998437}, {0.030000,2.000000}, {0.015000,2.175782}, {0.020625,1.998437}, {0.030000,2.000000}, {0.030000,1.644532}, {0.030000,1.554688},
  {0.021485,2.000001}, {0.024609,1.998437}, {0.023126,1.625000}, {0.030000,1.789063}, {0.030001,1.998437}, {0.030000,2.000000}, {0.030000,2.000000}, {0.030000,1.187500}, {0.030001,1.273438}, {0.030000,1.545312}, {0.018204,1.019531}, {0.030000,1.656251}, {0.030001,1.998437}}
  ,{ 2.847656, 1.000000, 6.285156, 2.160156, 3.128906, 1.125000, 1.000000, 4.972656, 1.750000, 3.722656, 1.031250}
  ,{ 43,  2,  4,  7,  9, 11, 13, 14, 16, 19, 21, 22, 24, 25, 27, 30, 32, 33, 35, 38, 40, 41} }

  ,{ "", -1 }
};

//////////////////  S U P P O R T   F U N C T I O N S  /////////////////////

////////////////////////////  G L O B A L  /////////////////////////////////

int     gCurSeg, gNxtSeg, gAftSeg, gPrvSeg;    // segment number
double  gWidth;            // road width
long    gCpt;              //
double  gCurLen, gNxtLen, gAftLen;
double  gCurLane, gNxtLane, gAftLane, gPrvLane;
double  gToEnd;            // distance to the end of the segment
double  gToEndAngle;       // distance to the end of the segment
double  gToLft;            // distance to the left of the road
double  gToRgt;            // distance to the rigth of the road
double  gCurAngle, gCurRadius;
int     gHalf;             // half of the segment (0,1)

double  gVn, gVt;          // speed of the car ./. car
double  gVmag;             // magnitude of the speed

double gBorderOutAdj;      //
double gBorderOutAdj2;     //
double gStartOut;
double gStartOut2;

T_track gTrack[MAX_SEG];   // precalculated data
T_border gBorder[MAX_SEG]; // precalculated borders
T_car gCar[MAXCARS];       // other cars data

double time_penality;      // optimization (penalty if too close from border)
int gUseOpti;              // use the optimized speed for each corner

static tControl c;
int gAlphaOld;
int gAlphaCpt;
int gAlpha[MAX_SEG];       // alpha_cpt for each begin of seg

int gStartPos;             // position 0-3
int gStartDist;            // distance 0-1
double gStartY;            // s.to_rgt (gCpt==0)

T_speed p2;
T_param p;

int gSaveSpeed = 0;        // save track.spd

int gCurveNb;              // number of curves

///////////////////////////  D E F I N E S  ////////////////////////////////

#define _DEBUG_                 1
#define SOFT_S_PRV           0.501172   // bAlpha, s.prv
#define BORDER(i)            gBorder[gTrack[i].curve]

///////////////////////// _ T R A C K . C P P //////////////////////////////
// paste here _track.cpp
//#ifndef BULLE_HOME
///////////////////////////  E X T E R N S  ////////////////////////////////

// bulle.cpp
 extern double gWidth;
 extern T_track gTrack[MAX_SEG];   // precalculated data
 extern T_border gBorder[MAX_SEG]; // precalculated borders
 extern int gUseOpti;              // use the optimized speed for each corner
 extern T_param p;
 extern T_speed p2;

// _opti.cpp
 extern double gOptiOne;

////////////////////////////  G L O B A L  /////////////////////////////////

track_desc t;

///////////////////////////////////////////////////////////////////////////

void bTrackInit()
{
   t = get_track_description();  // returns a track_desc
}

///////////////////////////////////////////////////////////////////////////

double bTrackGetRay( int seg )
{
   //// take the smallest radius
   if(t.trackin[seg].radius<0.0 ) return( t.trackout[seg].radius );
			     else return( t.trackin[seg].radius );
}

///////////////////////////////////////////////////////////////////////////

double bTrackGetLength( int seg )
{
   double rad = bTrackGetRay( seg );
   double len = t.trackout[seg].length;
   if (rad != 0.0) return ((fabs (rad) + 0.5 * gWidth) * len);
   return (len);
}

///////////////////////////////////////////////////////////////////////////

double bTrackGetAngle( int seg )
{
   if( t.trackin[seg].radius == 0.0 ) return 0.0;
				 else return t.trackout[seg].length;
}

///////////////////////////////////////////////////////////////////////////

void bTrackCalc( T_track_sub &tsub, int seg, double in, double out )
{
   //// calc the largest radius contained in the road
   //// (see calculations)
   double r1, r2, d1, d3, w, a;

   r1 = bTrackGetRay( seg );

   if( r1 == 0.0 ) {
      d1 = d3 = r2 = STRAIGHT_RAD;
   } else {
      if( r1<0.0 ) r1=-r1;
      r1 += in;
      w = t.width - in - out;

      // ST_CV_ST
      a = t.trackout[seg].length;
      d1 = w /( 1 - cos(a/2) );
      d3 = sin(a/2) * d1;
      r2 = r1 + d1;
   }

   tsub.r1 = r1;
   tsub.r2 = r2;
   tsub.d1 = d1;
   tsub.d3 = d3;
}

///////////////////////////////////////////////////////////////////////////

double bGetOutDist( situation&s )
{
   if( s.cur_rad>0.0 ) return s.to_lft;
		  else return s.to_rgt;
}

///////////////////////////////////////////////////////////////////////////

void bTrackCalcBorder( int seg )
{
   double in, out, out2;
   int curve = gTrack[seg].curve;

   // gTrack is already partially initializated
   in = p.BORDER_IN;
   out = p.BORDER_OUT;
   out2 = p.BORDER_OUT2;

   if( gUseOpti ) in = p2.border_in[curve];

   gBorder[curve].in   = in;
   gBorder[curve].out  = out;
   gBorder[curve].out2 = out2;
}

///////////////////  E N D   O F   _ T R A C K . C P P  ////////////////////
//#endif // BULLE_HOME

///////////////////////////////////////////////////////////////////////////

static void error( const char * txt )
{
#ifdef BULLE_HOME
   MessageBox( 0, txt, "Error", MB_OK );
#else
   fprintf(stderr, txt );
#endif // BULLE_HOME
   exit( 1 );
}

///////////////////////////////////////////////////////////////////////////

void bInit()
{
   #define TRAD( a ) t.trackout[ a ].radius
   #define TLEN( a ) t.trackout[ a ].length

   int i, type;
   char s[40], * pSz;
   static int param_init = 0;

   if( !no_display || param_init==0 ) 
   {

      // init only one time during optimalization
      param_init = 1;
      p=pdata[0];  // default

      // look if special parameters exist for the current track
      pSz = strchr( trackfile[current_track], '/' );
      if( pSz==NULL) 
         strcpy( s, trackfile[current_track] );
      else 
         strcpy( s, pSz+1 );
      for( i=0; pdata[i].surface!=-1; i++ ) 
      {
         if( !strcmp(pdata[i].trackfile,s) && pdata[i].surface==surface ) 
         {
	        p=pdata[i];  // get the parameters
	        break;       // finish
         }
      }

      // look if special speeds exist for the current track
      gUseOpti = 0;
      if( gSaveSpeed==0 ) 
      {
	     for( i=0; sdata[i].surface!=-1; i++ ) 
         {
	        if( !strcmp(sdata[i].trackfile,trackfile[current_track]) && sdata[i].surface==surface ) 
            {
	           p2=sdata[i];  // get the parameters
	           gUseOpti = 1;
	           break;        // finish
            }
         }
      }
   }

////
//// calcule r2 pour chaque tournant du circuit
////
   bTrackInit();
   if( t.NSEG > MAX_SEG ) error("<<Bulle>> bInit : too much segments");
   gWidth = t.width;
   gCurveNb = 0;
   for( i=0; i<t.NSEG; i++ ) {

      gTrack[i].curve = gCurveNb;
      gTrack[i].length = bTrackGetLength( i );

      // curve type
      if( TRAD( i ) == 0.0 ) type = CUR_ST;    // straight
      else {
	 gCurveNb++;
	 if( TRAD( i ) > 0.0 ) type = CUR_LC;  // left curve
			  else type = CUR_RC;  // right curve
      }
      gTrack[i].type = type;
      bTrackCalcBorder( i );

      bTrackCalc( gTrack[i].t[0], i, BORDER(i).in, BORDER(i).out);
      bTrackCalc( gTrack[i].t[1], i, BORDER(i).in, BORDER(i).out2);
   }

////
//// calc the speed for each half segment
////
   for( i=0; i<t.NSEG; i++ ) {
      gTrack[i].t[0].speed = bSpeed2( i, 0, gTrack[i].t[0].control );
      gTrack[i].t[1].speed = bSpeed2( i, 1, gTrack[i].t[1].control );
   }
////
//// init gCar (other cars data)
////
   for( i=0; i<car_count; i++ ) {
      gCar[i].laps = 0;
      gCar[i].when = 0;
      gCar[i].old_avg = 0.0;
   }

   gBorderOutAdj = 0;
}

////////////////////////////////////////////////////////////////////////////

static int bGetCurveType( int seg, double pos, tControl &c )
{
////
//// define
////
   // type
   #define STRAIGHT_LONG_U     0
   #define STRAIGHT_LONG_S     1
   #define STRAIGHT_SHORT_U    2
   #define STRAIGHT_SHORT_S    3
   #define STRAIGHT_VSHORT_S   4
   #define CURVE_1H_INSIDE     5
   #define CURVE_2H_INSIDE     6
   #define CURVE_1H_OUTSIDE    7
   #define CURVE_2H_OUTSIDE    8
   #define CURVE_1H_IN_S       9
   #define CURVE_2H_IN_S      10

   // type2
   #define STRAIGHT_INSIDE     0
   #define STRAIGHT_OUTSIDE    1
   #define STRAIGHT_OUT_IN     2
   #define STRAIGHT_NXT        3
   #define STRAIGHT_PRV        4
   #define STRAIGHT_MIX        5
   #define STRAIGHT_MIX3       6
   #define STRAIGHT_MIX4       7

   // tControl.alpha
   #define CALPHA_S_INSIDE     0
   #define CALPHA_S_OUTSIDE    1
   #define CALPHA_S_PRV        2
   #define CALPHA_S_NXT        3
   #define CALPHA_S_MIX        4
   #define CALPHA_C_INSIDE     5
   #define CALPHA_C_1H_OUTSIDE 6
   #define CALPHA_C_2H_OUTSIDE 7
   #define CALPHA_C_1H_IN_S    8
   #define CALPHA_C_2H_IN_S    9
   #define CALPHA_S_MIX2       10
   #define CALPHA_S_MIX3       11
   #define CALPHA_S_MIX4       12
   #define CALPHA_S_OUT_IN     13

   // tControl.speed
   #define CSPEED_S_MAX        0
   #define CSPEED_S_NXT        1
   #define CSPEED_S_PRV        2
   #define CSPEED_C_INSIDE     3
   #define CSPEED_C_OUTSIDE    4

//// variables
   int type, type2;                                   // return
   int prv_seg = my_mod(seg+t.NSEG-1,t.NSEG);
   int nxt_seg = my_mod(seg+1,t.NSEG);
   int cur_seg_type = gTrack[seg].type;
   int nxt_seg_type = gTrack[nxt_seg].type;
   int prv_seg_type = gTrack[prv_seg].type;
   double prv_d3 = gTrack[prv_seg].t[1].d3;
   double nxt_d3 = gTrack[nxt_seg].t[0].d3;
   double cur_length = gTrack[seg].length;
////
//// qXxx = questions
////
   // 0: prv_d3<pos< nxt_d3  1: pos<prv_d3  2: nxt_d3<pos
   int auxStraightPos1 = cur_length-pos < prv_d3;
   int auxStraightPos2 = pos < nxt_d3;
   int qStraightPos = auxStraightPos1 + auxStraightPos2*2;
   // LongStraight
   int qLongStraight = prv_d3+nxt_d3 < cur_length;
   // for qLongStraight2, qLongStraight3
   double pd3=min(prv_d3,500);
   double nd3=min(nxt_d3,500);
   int qLongStraight2 = pd3+nd3+p.STRAIGTH_SHORT2 < cur_length;
   int qLongStraight3 = (pd3*p.STRAIGTH_SHORT3<cur_length) &&(nd3*p.STRAIGTH_SHORT3<cur_length) ;
   int qCurveFirstHalf = pos > cur_length*0.5;
   int qNxtStraightType = (nxt_seg_type==CUR_ST)?bGetCurveType(nxt_seg,0,c):0;
   int qPrvStraightType = (prv_seg_type==CUR_ST)?bGetCurveType(prv_seg,0,c):0;

////
//// find the type of the curve
////
   if( cur_seg_type == CUR_ST ) {
      // straigth
      if( nxt_seg_type == prv_seg_type ) {
	 // LC_ST_LC -- RC_ST_RC
	 if( qLongStraight ) {
	    type = STRAIGHT_LONG_U;
	    switch( qStraightPos ) {
	       case 0: type2 = STRAIGHT_OUTSIDE; break;
	       case 1: type2 = STRAIGHT_PRV; break;
	       case 2: type2 = STRAIGHT_NXT; break;
	       case 3: type2 = STRAIGHT_NXT; break;        // never
	    }
	 } else {
	    type = STRAIGHT_SHORT_U;
	    type2 = STRAIGHT_INSIDE;
	 }
      } else {
	 // it's a S
	 if( qLongStraight2 ) {
	    type = STRAIGHT_LONG_S;
	    type2 = STRAIGHT_MIX;
	 } else if( qLongStraight3 ) {
	    type = STRAIGHT_SHORT_S;
	    switch( qStraightPos ) {
	       case 0: type2 = STRAIGHT_OUT_IN; break;
	       case 1: type2 = STRAIGHT_PRV; break;
	       case 2: type2 = STRAIGHT_OUT_IN; break;
	       case 3: type2 = STRAIGHT_PRV; break;
	    }
	 } else {
	    type = STRAIGHT_VSHORT_S;
	    switch( qStraightPos ) {
	       case 0: type2 = STRAIGHT_OUT_IN; break; // never
	       case 1: type2 = STRAIGHT_PRV; break;
	       case 2: type2 = STRAIGHT_NXT; break;
	       case 3: type2 = STRAIGHT_MIX4; break;
	    }
	 }
      }
   } else {
       if( qCurveFirstHalf ) {
	  // first half of the curve
	  if( prv_seg_type==CUR_ST ) {
	     if( qPrvStraightType != STRAIGHT_SHORT_S ) {
		// stay outside the corner
		type = CURVE_1H_OUTSIDE;
	     } else {
		// stay inside the corner
		type = CURVE_1H_INSIDE;
	     }
	  } else if( cur_seg_type == prv_seg_type ) {
	     type = CURVE_1H_INSIDE;
	  } else {
	     type = CURVE_1H_IN_S;
	  }
       } else {
	  // second half of the curve
	  if( nxt_seg_type==CUR_ST ) {
	     if( qNxtStraightType == STRAIGHT_LONG_S
	     || qNxtStraightType == STRAIGHT_SHORT_U
	     || qNxtStraightType == STRAIGHT_LONG_U ) {
		// stay outside the corner
		type = CURVE_2H_OUTSIDE;
	     } else {
		// stay inside the corner
		type = CURVE_2H_OUTSIDE;
	     }
	  } else if( cur_seg_type == nxt_seg_type ) {
	     type = CURVE_2H_INSIDE;
	  } else {
	     type = CURVE_2H_IN_S;
	  }
       } // first half
   } // cur_type

////
//// depending the type, the car uses different formulas to calculate
//// its speed and its direction.
////
   switch( type ) {
     case STRAIGHT_LONG_S:
     case STRAIGHT_LONG_U:
     case STRAIGHT_SHORT_S:
     case STRAIGHT_VSHORT_S:
//     case STRAIGHT_SHORT_U:
	switch( type2 ) {
	   case STRAIGHT_INSIDE:
	      c.alpha = CALPHA_S_INSIDE;
	      c.speed = CSPEED_S_MAX;
	      break;
	   case STRAIGHT_OUTSIDE:
	      c.alpha = CALPHA_S_OUTSIDE;
	      c.speed = CSPEED_S_MAX;
	      break;
	   case STRAIGHT_OUT_IN:
	      c.alpha = CALPHA_S_OUT_IN;
	      c.speed = CSPEED_S_MAX;
	      break;
	   case STRAIGHT_PRV:
	      c.alpha = CALPHA_S_PRV;
	      c.speed = CSPEED_S_PRV;
	      break;
	   case STRAIGHT_NXT:
	      c.alpha = CALPHA_S_NXT;
	      c.speed = CSPEED_S_NXT;
	      break;
	   case STRAIGHT_MIX:
	   case STRAIGHT_MIX3:
	      c.alpha = CALPHA_S_MIX3;
	      c.speed = CSPEED_S_MAX;
	      break;
	   case STRAIGHT_MIX4:
	      c.alpha = CALPHA_S_MIX4;
	      c.speed = CSPEED_S_MAX;
	      break;
	}
	break;
     case STRAIGHT_SHORT_U:
	c.alpha = CALPHA_S_MIX2;
	c.speed = CSPEED_S_MAX;
	break;

     case CURVE_1H_INSIDE:
     case CURVE_2H_INSIDE:
	c.alpha = CALPHA_C_INSIDE;
	c.speed = CSPEED_C_INSIDE;
	break;
     case CURVE_1H_OUTSIDE:
	c.alpha = CALPHA_C_1H_OUTSIDE;
	c.speed = CSPEED_C_OUTSIDE;
	break;
     case CURVE_2H_OUTSIDE:
	c.alpha = CALPHA_C_2H_OUTSIDE;
	c.speed = CSPEED_C_OUTSIDE;
	break;
     case CURVE_1H_IN_S:
	c.alpha = CALPHA_C_1H_IN_S;
	c.speed = CSPEED_C_OUTSIDE;
	break;
     case CURVE_2H_IN_S:
	c.alpha = CALPHA_C_2H_IN_S;
	c.speed = CSPEED_C_OUTSIDE;
	break;
   }

   return( type );
}

////////////////////////////////////////////////////////////////////////////

static double bSpeedMin( int seg )
{
    return( p.SPEED_MAG_MIN * sqrt( gTrack[seg].t[gHalf].r1 ) );
}

static double bSpeedStCvSt( int seg )
{
    return( p.SPEED_MAG * sqrt( gTrack[seg].t[gHalf].r2 ) );
}

////////////////////////////////////////////////////////////////////////////

double bSpeed2( int seg, int half, tControl &c )
{
////
//// variable
////
    double s;
    if( half==0 ) bGetCurveType( seg, 1000000, c ) ;
	     else bGetCurveType( seg, 0, c ) ;

////
//// precalc
////
     if( gUseOpti==1 ) {
	// optimized speed
        if( half==1 ) return( p2.speed[seg].s1 );
		 else return( p2.speed[seg].s2 );
     }

////
//// speed
////
    switch( c.speed ) {
       case CSPEED_S_MAX:
       case CSPEED_S_NXT:
       case CSPEED_S_PRV:
	  s = STRAIGHT_SPD;
	  break;
       case CSPEED_C_INSIDE:
	  s = bSpeedMin( seg );
	  break;
       case CSPEED_C_OUTSIDE:
	  s = bSpeedStCvSt( seg );
	  break;
    }
    return( s );
}

////                                                                    ////
 //   calculate segment length (for both curves and straights), in feet  //
////                                                                    ////

static double bSegLength( double rad, double len, double width )
{
    if (rad != 0.0) return ((fabs (rad) + 0.5 * width) * len);
    return (len);
}

////                                                                    ////
 //     decides which lane to drive on (lane selection, wrt to left)     //
////                                                                    ////

///////////////////////////////////////////////////////////////////////////

static int bInS( int seg )
// retourne 1 si on est dans un S
{
   int nseg = my_mod(seg+1,t.NSEG);
   if( gTrack[seg].type==gTrack[nseg].type ) return 0;
   if( gTrack[seg].type+gTrack[nseg].type==3 ) return 1;

   int aseg = my_mod(seg+2,t.NSEG);
   if( gTrack[seg].type==gTrack[aseg].type ) return 0;
   return 1;
}

/////////////////////// C A L C _ A L P H A ////////////////////////////////

static double bLaneCur()
{
    double b, sinb, cosb, r1, r2, d1, aux, lane;
    int seg = gCurSeg;

    if( gTrack[seg].type == CUR_ST ) {
       // straight
       lane = 0.5 * gWidth;             // never used
    } else {
       // curve
       d1 = gTrack[ seg ].t[gHalf].d1;
       r1 = gTrack[ seg ].t[gHalf].r1;
       r2 = gTrack[ seg ].t[gHalf].r2;
       b = fabs( gToEndAngle - gCurAngle/2 );

       sinb = sin( b );
       cosb = cos( b );

       aux = d1*sinb;
       if( aux>r2 ) aux=r2;
       lane = sqrt( r2*r2 - aux*aux ) -cosb*d1 -r1;
       lane+= BORDER(seg).in;
    }

    if( gTrack[seg].type==CUR_LC ) return( lane );
			      else return( gWidth-lane );
}

////////////////////////////////////////////////////////////////////////////

static double bLaneNex( double to_end, double out )
{
    double  r2, d3, aux, lane;
    int seg = gNxtSeg;

    if( gTrack[seg].type == CUR_ST ) {
       lane = 0.5 * gWidth;
    } else {
       r2 = gTrack[ seg ].t[0].r2;
       d3 = gTrack[ seg ].t[0].d3;
       if( to_end>d3 ) {
	  lane = gWidth - out;
       } else {
	  aux = d3 - to_end;
	  if( aux>r2 ) aux=r2;
	  lane = r2 - sqrt( r2*r2 - aux*aux );
	  lane= gWidth - out - lane;
       }
    }

    if( gTrack[seg].type==CUR_LC ) return( lane );
			      else return( gWidth-lane );
}

////////////////////////////////////////////////////////////////////////////

static double bLanePrv( double to_end, double out )
{
    double r2, d3, aux, lane;
    int seg = gPrvSeg;

    if( gTrack[seg].type == CUR_ST ) {
       // straight
       lane = 0.5 * gWidth;             // never used
    } else {
       // curve
       r2 = gTrack[ seg ].t[1].r2;
       d3 = gTrack[ seg ].t[1].d3;
       if( to_end>d3 ) {
	  // before the curve
	  lane = gWidth - BORDER(seg).out2;
       } else {
	  // begin of the curve
	  aux = d3 - to_end;
	  if( aux>r2 ) aux = r2;   // sometimes gToEnd<0
	  lane = r2 - sqrt( r2*r2 - aux*aux );
	  lane= gWidth - out - lane;
       }
    }

    if( gTrack[seg].type==CUR_LC ) return( lane );
			      else return( gWidth-lane );
}

////////////////////////////////////////////////////////////////////////////

static double bCalc_MixLane( double pos1, double v1, double pos2, double v2 )
{
  double lane;

  if( gToEnd<pos1 ) {          // end of the straigth
     lane = v1;
  } else if( gToEnd>pos2 ) {   // begin of the straigth
     lane = v2;
  } else {
     // y = f(x)
     //   = y1 + (y2-y1)/(x2-x1)*(x-x1)
     lane = v1 + (v2-v1)/(pos2-pos1)*(gToEnd-pos1);
  }

  return( lane );
}

////////////////////////////////////////////////////////////////////////////

static double bCalcAlpha2( situation & s )
{
////
//// static
////
    static double old_lane;
    static int old_seg;
    static int old_alpha;

    if( gCpt==1 ) {
       old_lane = gToLft;
       old_seg = old_alpha = -1;
    }
////
//// variable
////
    double lane, alpha, f;
    bGetCurveType( gCurSeg, gToEnd, c );
    double ALPHA_MAG = p.ALPHA_MAG_INI;
    double SLIDE_MAG = p.SLIDE_MAG_INI;

    // out (par rapport a Prv)
    double out, out_nxt, f1, f2, nxt_pos0, prv_pos0 ;
    if( bInS(gPrvSeg) ) {
       f1 = BORDER(gNxtSeg).out;
    } else {
       f1 = BORDER(gNxtSeg).out+gBorderOutAdj2;
    }
    f2 = BORDER(gPrvSeg).out2;
    nxt_pos0 =  min(gTrack[gNxtSeg].t[0].d3,gCurLen);
    prv_pos0 =  max(gCurLen-gTrack[gPrvSeg].t[1].d3,0.0);
    out = max( bCalc_MixLane( nxt_pos0, f1, prv_pos0, f2 )
                ,gStartOut2 
              );
    // out (par rapport a nxt)
    out_nxt = BORDER(gNxtSeg).out+gBorderOutAdj2;

    double gCurLane = bLaneCur();
    double gNxtLane = bLaneNex( gToEnd, out_nxt );
    double gPrvLane = bLanePrv( gCurLen - gToEnd, out );
    double aux = 0.5 * gCurLen;
    double ratio01 = (gCurLen-gToEnd)/gCurLen;     // 0->1
    double ratio02 = gToEnd/gCurLen;               // 1->0
    double ratio12 = (1.5*gCurLen-gToEnd)/gCurLen; // firt half:   0,5->1
    double ratio22 = (gToEnd-aux)/gCurLen;         //              0,5->0
    double ratio13 = (aux-gToEnd)/gCurLen;         // second half: 0->0,5
    double ratio23 = (gToEnd+aux)/gCurLen;         //              1->0,5

    double nxt_d3 = gTrack[gNxtSeg].t[0].d3;
    double len = gCurLen - nxt_d3;
    aux = 0.5 * len;
    double ratio1, ratio2;
    if( gToEnd < nxt_d3 ) {
      ratio1 = 1; ratio2=0;
    } else {
      ratio1 = (gCurLen-gToEnd)/len;               // 0->1
      ratio2 = (gToEnd-nxt_d3)/len;                // 1->0
    }
////
//// debug help
////
    if( gCurSeg != old_seg ) 
    {
       // set a breakpoint here
       old_seg = gCurSeg;
       // save in spd file
       #ifdef BULLE_HOME
	   if( gSaveSpeed ) 
       {
	      OptiSaveOne2( p2.border_in, gTrack[gCurSeg].curve, BORDER(gCurSeg).in );
	      OptiSaveOneInt( p2.alpha_cpt, gCurSeg, gAlphaCpt);
       }
       #endif // BULLE_HOME
       // ...
       gBorderOutAdj2 = min( gBorderOutAdj, gWidth-BORDER(gNxtSeg).in-BORDER(gNxtSeg).out-10.0 );
       gBorderOutAdj  = 0;
       gStartOut2     = min( gStartOut, gWidth-BORDER(gNxtSeg).in-BORDER(gNxtSeg).out-10.0 );
       gStartOut      = 0;     
       if( gCurRadius!=0.0 && gCurAngle/gCurRadius<0.002 )
	  gBorderOutAdj2 /=4;
       if( gUseOpti ) {
	  gAlphaCpt=p2.alpha_cpt[gCurSeg];
	  if( gBorderOutAdj2<1.0 ) gUseOpti = 1;
			      else gUseOpti = 2;
       }
       bTrackCalc( gTrack[gNxtSeg].t[0], gNxtSeg, BORDER(gNxtSeg).in, BORDER(gNxtSeg).out+gBorderOutAdj2 );
       gTrack[gNxtSeg].t[0].speed = bSpeed2( gNxtSeg, 0, gTrack[gNxtSeg].t[0].control );
    }

    if( c.alpha != old_alpha )
       // set a breakpoint here
       old_alpha = c.alpha;
////
//// lane
////
    // local variables for the case (incompatibility BC++ OS/2)
    double old, nxt_lane0, prv_lane0, ref_lane;

    double OldLane = old_lane;
    if( gTrack[gPrvSeg].type==CUR_RC ) OldLane = gWidth-OldLane;

    switch( c.alpha ) {
       case CALPHA_S_INSIDE:
	  lane = (3*OldLane+BORDER(gCurSeg).in)/4.0;
	  break;
       case CALPHA_S_OUT_IN:
       case CALPHA_S_OUTSIDE:
	  lane = gWidth-out;
	  ALPHA_MAG = p.ALPHA_MAG_S_OUTSIDE;
	  SLIDE_MAG = p.SLIDE_MAG_S_OUTSIDE;
	  break;
       case CALPHA_S_NXT:
	  lane = gNxtLane;
	  SLIDE_MAG = p.SLIDE_MAG_S_NXT;
	  break;
       case CALPHA_S_PRV:
	  lane = gPrvLane;
	  if( gTrack[gPrvSeg].type==CUR_RC ) {
	     if( gToLft-lane<0 ) old_lane = (old_lane+lane)*SOFT_S_PRV;
	  } else {
	     if( gToLft-lane>0 ) old_lane = (old_lane+lane)*SOFT_S_PRV;
	  }
	  ALPHA_MAG = p.ALPHA_MAG_S_PRV;
	  SLIDE_MAG = p.SLIDE_MAG_S_PRV;
	  break;
       case CALPHA_S_MIX:
	  lane = gNxtLane*ratio1 + gPrvLane * ratio2;
          if( gToLft-lane>0 ) old_lane = (old_lane+lane)*0.5;
	  ALPHA_MAG = p.ALPHA_MAG_S_MIX;
	  break;
       case CALPHA_S_MIX2:
	  nxt_lane0 = bLaneNex( gCurLen, out_nxt );
	  prv_lane0 = bLanePrv( gCurLen, out );
	  nxt_pos0 =  gCurLen;
	  prv_pos0 =  max(gCurLen-gTrack[gPrvSeg].t[1].d3,0.0);
	  ref_lane = bCalc_MixLane(
			prv_pos0, prv_lane0,
			nxt_pos0, nxt_lane0
		     );
	  lane = gPrvLane+gNxtLane-ref_lane;
	  if( gTrack[gPrvSeg].type==CUR_RC ) {
	     if( lane > gWidth-p.BORDER_IN ) lane = gWidth-p.BORDER_IN;
	  } else {
	     if( lane < p.BORDER_IN ) lane = p.BORDER_IN;
	  }
	  ALPHA_MAG = p.ALPHA_MAG_S_MIX2;
	  SLIDE_MAG = p.SLIDE_MAG_S_MIX2;
	  if( nxt_pos0==gCurLen ) {
	     ALPHA_MAG = p.ALPHA_MAG_S_MIX2b;
	     SLIDE_MAG = p.SLIDE_MAG_S_MIX2b;
	  }
	  break;
       case CALPHA_S_MIX3:
	  lane = gNxtLane*ratio01 + gPrvLane * ratio02;
	  ALPHA_MAG = p.ALPHA_MAG_S_MIX3;
	  SLIDE_MAG = p.SLIDE_MAG_S_MIX3;
	  break;
       case CALPHA_S_MIX4:
	  nxt_pos0 =  min(gTrack[gNxtSeg].t[0].d3,gCurLen);
	  prv_pos0 =  max(gCurLen-gTrack[gPrvSeg].t[1].d3,0.0);
	  nxt_lane0 = bLaneNex( gCurLen-prv_pos0, out_nxt );
	  prv_lane0 = bLanePrv( nxt_pos0, out );
	  ref_lane = bCalc_MixLane(
			prv_pos0, prv_lane0,
			nxt_pos0, nxt_lane0
		     );
	  lane = gPrvLane+gNxtLane-ref_lane;
	  if( gTrack[gPrvSeg].type==CUR_RC ) {
	     if( lane > gWidth-p.BORDER_IN ) lane = gWidth-p.BORDER_IN;
	  } else {
	     if( lane < p.BORDER_IN ) lane = p.BORDER_IN;
	  }
	  ALPHA_MAG = p.ALPHA_MAG_S_MIX4;
	  SLIDE_MAG = p.SLIDE_MAG_S_MIX4;
	  break;
       case CALPHA_C_INSIDE:
	  old = old_lane;
	  if( gTrack[gCurSeg].type==CUR_RC ) old = gWidth-old;
	  lane = (3*old+BORDER(gCurSeg).in)/4.0;
	  ALPHA_MAG = p.ALPHA_MAG_C_INSIDE;
	  SLIDE_MAG = p.SLIDE_MAG_C_INSIDE;
	  break;
       case CALPHA_C_1H_OUTSIDE:
	  lane = gCurLane;
	  ALPHA_MAG = p.ALPHA_MAG_C_1H_OUTSIDE;
	  SLIDE_MAG = p.SLIDE_MAG_C_1H_OUTSIDE;
	  break;
       case CALPHA_C_2H_OUTSIDE:
	  lane = gCurLane;
	  if( gTrack[gCurSeg].type==CUR_RC ) {
	     if( gToLft-lane<0 ) old_lane = (old_lane+lane)*0.5;
	  } else {
	     if( gToLft-lane>0 ) old_lane = (old_lane+lane)*0.5;
	  }
	  ALPHA_MAG = p.ALPHA_MAG_C_2H_OUTSIDE;
	  SLIDE_MAG = p.SLIDE_MAG_C_2H_OUTSIDE;
	  break;
       case CALPHA_C_1H_IN_S:
	  lane  = gCurLane*ratio12 + gPrvLane * ratio22;
	  ALPHA_MAG = p.ALPHA_MAG_C_1H_IN_S;
	  SLIDE_MAG = p.SLIDE_MAG_C_1H_IN_S;
	  break;
       case CALPHA_C_2H_IN_S:
	  lane  = gNxtLane*ratio13 + gCurLane * ratio23;
	  ALPHA_MAG = p.ALPHA_MAG_C_2H_IN_S;
	  break;
    }
////
////  change lane for right curve
////
    switch( c.alpha ) {
       case CALPHA_S_INSIDE:
       case CALPHA_S_OUTSIDE:
       case CALPHA_S_OUT_IN:
	  if( gTrack[gPrvSeg].type==CUR_RC ) lane = gWidth-lane;
	  break;
       case CALPHA_C_INSIDE:
	  if( gTrack[gCurSeg].type==CUR_RC ) lane = gWidth-lane;
	  break;
    }

////
//// save ALPHA_MAG, SLIDE_MAG for future optimization
////


    if( c.alpha != gAlphaOld ) {
       gAlphaOld = c.alpha;
       gAlphaCpt++;
       if(gCurSeg==0 &&  gAlphaCpt>3 )
	  gAlphaCpt=0;
       #ifdef BULLE_HOME
	  if( gSaveSpeed ) {
	     OptiSaveOne( p2.alpha, gAlphaCpt, ALPHA_MAG, SLIDE_MAG );
	     p2.AlphaNb = gAlphaCpt+1;
	  }
       #endif // BULLE_HOME
    }

    if( gUseOpti==1 ) {
       if( gAlphaCpt>p2.AlphaNb-1 ) gAlphaCpt=p2.AlphaNb-1;
       ALPHA_MAG = p2.alpha[gAlphaCpt].s1;
       SLIDE_MAG = p2.alpha[gAlphaCpt].s2;
    }

////
//// start
////
    if( gCpt<p.ALPHA_START) return( 0 );

////
//// after refuel
////
    if( s.fuel>149.95 && gCpt>1000 ) {
       ALPHA_MAG = p.ALPHA_MAG_INI;
       SLIDE_MAG = p.SLIDE_MAG_INI;
    }

////
//// alpha
////
    f = (old_lane-lane)/(gVmag*delta_time);
    if( f<-0.7 ) f = -0.7;
    if( f>0.7 ) f =0.7;
    f = asin( f );
    alpha = f;
    alpha += ALPHA_MAG * (gToLft - lane);
    old_lane = lane;


    if( gTrack[gCurSeg].type==CUR_LC )
       alpha += asin(s.v*delta_time/(gCurRadius+gToLft));
    if( gTrack[gCurSeg].type==CUR_RC )
       alpha += asin(s.v*delta_time/(gCurRadius-gToRgt));
    alpha -= SLIDE_MAG*asin(s.vn/s.v);

    // prevent to go out of the track

    // correct alpha if it predicts that the car goes out
    //  (not used during optimization)
    // avoid the border during the start more than during the race
    f = 2.0;                                   // race

    if( !no_display ) {
       if (s.vn > (f*gToLft))
	      alpha -= 0.1*( s.vn-f*gToLft );
       if (-s.vn > (f*gToRgt))
	       alpha += 0.1*( -s.vn-f*gToRgt );

       // correct alpha if too close from the border
       if( gToLft<2.0 )
	      if( gToLft>1.5 ) alpha += -(2.0-gToLft);
	   else alpha += -0.5;
       if( gToRgt<2.0 )
	      if( gToRgt>1.5 ) alpha += (2.0-gToRgt);
	   else alpha += 0.5;
    } else {
       // optimization
       f=1.5; // plus sensible
       if (s.vn > (f*gToLft) ) time_penality += 0.1*( s.vn-f*gToLft );
       if (-s.vn > (f*gToRgt) ) time_penality += 0.1*(-s.vn-f*gToRgt );
    }

    if (alpha < -1.57) alpha = -1.57;
    if (alpha > 1.57) alpha = 1.57;

    return( alpha );
}

////////////////////////////////////////////////////////////////////////////

////                                                                    ////
 //     calculate braking distance using current and goal speed          //
////                                                                    ////

#define SPEED(a,b) gTrack[a].t[b].speed
#define CONTROL(a,b) gTrack[a].t[b].control

static double bBrakeDist( double cur_v, double nex_v )
{
    return ((sqr(cur_v) - sqr(nex_v))/(2*p.DECEL));
}

static double bBrakeDist2( int seg, double cur_v )
{
    double d3 = 0.0;
    int nxt_seg = my_mod(seg+1,t.NSEG);

    if( CONTROL(nxt_seg,0).speed == CSPEED_C_OUTSIDE ) {
       d3 = gTrack[nxt_seg].t[0].d3;
       if( d3 >  gTrack[seg].t[0].d3 ) d3 = gTrack[seg].t[0].d3;
    }
    return ((sqr(cur_v) - sqr( SPEED(nxt_seg,0) ))/(2*p.DECEL) + d3 );
}

////////////////////////////////////////////////////////////////////////////

static double bCalcVcSub()
{
// calculate target speeds for the three track segments

////
//// static
////
   static int brake_nxt;
   static int old_seg;

   if( gCurSeg != old_seg || gCpt==1 ) {
      // set a breakpoint here
      old_seg = gCurSeg;
      brake_nxt = 0;
   }

////
//// speeds
////
   double speed_cur1 = SPEED(gCurSeg,0);
   double speed_cur2 = SPEED(gCurSeg,1);
   double speed_nxt1 = SPEED(gNxtSeg,0);

////
//// save speed for future optimization
////
   #ifdef BULLE_HOME
      if( gSaveSpeed )
         OptiSaveOne( p2.speed, gCurSeg, speed_cur1, speed_cur2 );
   #endif // BULLE_HOME

   // now set the tire speed = vc, brake if neccessary
   if( gToEnd+gNxtLen+gAftLen < bBrakeDist2(gAftSeg, gVt) )
       return SPEED( my_mod(gCurSeg+3,t.NSEG), 0 );
   double dist_aft = gToEnd+gNxtLen;
   if( gTrack[gNxtSeg].type!=CUR_ST ) dist_aft = gToEnd+gNxtLen/1.5;
   if( dist_aft < bBrakeDist2(gNxtSeg, gVt) )
       return SPEED(gAftSeg,0);                // 'after' segment

   // calculate braking distance for the next segment
   double brake_dist_nxt = bBrakeDist2(gCurSeg, gVt );
   if( gTrack[gCurSeg].type!=CUR_ST ) brake_dist_nxt *= 1.5;
   brake_nxt =(gToEnd < brake_dist_nxt)?1:0;
   if( brake_nxt )
      return speed_nxt1;                      // brake for next corner

   if( gVt<speed_nxt1 ) {
      if( gCurAngle != 0.0 ) {
	 if( gToEnd < ((p.START_ACC-p.START_ACC2*gCurAngle) * gCurLen) )
	       return speed_nxt1;                  // accelerate for next segment
      }
   }

   // keep current speed
   double brake_dist_cur12 = bBrakeDist(gVt, speed_cur2);
   if( brake_dist_cur12<0 ) brake_dist_cur12 = 0;
   if( gToEnd-1.5*brake_dist_cur12 > gCurLen*0.5 )
      return speed_cur1;
   else
      return speed_cur2;
}

////////////////////////////////////////////////////////////////////////////

static double bCalcVc3( situation & s )
{
    double vc = bCalcVcSub();

////
//// before refueling
////
    if( s.fuel<0.05 ) {
       vc = vc*( 1.0-(16.0*(0.05-s.fuel)) );
    }

    return( vc );
}

////////////////////////////////////////////////////////////////////////////

static void bPassingNo(  situation & s, double &vc )
{
////
//// slow down if a car in front
////
    for( int i=0;i<3; i++) if (s.nearby[i].who<16) {
					     // if there is a close car
       double x=s.nearby[i].rel_x;           // get forward distance
       double y=s.nearby[i].rel_y;           // get right distance
       double vy=s.nearby[i].rel_ydot;       // get lateral relative speed

       // if the car is getting closer
       if( y<2.0*CARLEN ) 
	  vc = min(vc,s.v+vy-20);
       else if( vy<0.0 && (y<4.6*CARLEN || y<-10.0*vy) )
          vc = max(50,min(vc,s.v+vy-5.0)); 
    }
}

////////////////////////////////////////////////////////////////////////////

static void bPassing4( situation & s, /*double &alpha,*/ double &vc, double param)
{
/* 
  #define DIST_FRONT      7
  #define DIST_BACK       1
  #define DIST_SIDE_SLOW  2
  #define DIST_SIDE_FAST  6
*/
  #define DIST_FRONT      5
  #define DIST_BACK       1
  #define DIST_SIDE_SLOW  1
  #define DIST_SIDE_FAST  1

  static int iBrakeTime = 0;

  for (int j=0; j<2; j++) 
  {
      int who = s.nearby[j].who;
	  if (who < 16)
      {
          double px, py, x, y, vx, vy, ax, ay, t, ang, aux;
          int bCollide;

          ang = 0;
          x = s.nearby[j].rel_x;
          y = s.nearby[j].rel_y;
          vx = s.nearby[j].rel_xdot;
          vy = s.nearby[j].rel_ydot;
          ax = ay = 0;
	  	  if( gCar[who].old_cpt >= OLD_CPT_MIN ) 
          {
              ax = ( vx - gCar[who].old_vx ) / OLD_CPT_MIN; 
              ay = 0; // ( vy - gCar[who].old_vy ) / OLD_CPT_MIN; 
          } 

          if( s.v+vy ) 
          {
              ang = atan((s.vn+vx)/(s.v+vy)) - atan(s.vn/s.v);
          }

          bCollide = collide( x,y,ang);
          aux = ( vy<-40 )?DIST_SIDE_FAST:DIST_SIDE_SLOW;
          aux *= param;

          // 18 times /s
          for( t=0.0;t<=1.0;t+=0.0549 ) 
          {
              px = x+vx*t+ax*t*t;
              py = y+vy*t+ay*t*t;
              if( py>0.0 && py<CARLEN*1.4 ) 
              {
                  bCollide |= collide( px,py,ang);
                  bCollide |= collide( px-aux,py+DIST_BACK ,ang );
                  bCollide |= collide( px-aux,py-DIST_FRONT,ang );
                  bCollide |= collide( px+aux,py+DIST_BACK ,ang );
                  bCollide |= collide( px+aux,py-DIST_FRONT,ang );
                  if( bCollide )
                  {
                      if( vc > s.v+vy )
                      {
                          if( y<CARLEN ) 
                          {
                              vc = 0;
                              iBrakeTime = 3;
                          }
                          else if (y<2*CARLEN&&vy<-40) 
                          {
                              vc = 0;
                          }
                          else
                          {
                              vc = s.v+vy;
						  }
                      }
                      break; 
                  }
              }
          }
      }
  }

  if( iBrakeTime>0 ) 
  {
      iBrakeTime --;      
      vc = 0; 
  }
  gBorderOutAdj *= 0.85;
}

////////////////////////////////////////////////////////////////////////////

static void bPassingMain( situation & s, /*double &alpha,*/ double &vc )
{
/////  during the start, don't modify the trajectory
/////
    if( gStartDist==0 && gCpt<p.ALPHA_START+100 ) {
       if( vc-30>s.v ) vc = 400;
       return;
    }

///// if the car is the first, slow down if it's possible to see the second
/////  => don't need to overtake the second
    if( s.position==0) {
       int can_see_second = 0;
       static can_see_end = 0;
       // find who is the second
       //  position is defined static :(
       int second_nb = 0;
       if( s.my_ID==0 ) second_nb=1;
       for (int i=0;i<car_count;i++) {
	   if( i==s.my_ID ) continue;
	   if( farther( pcar[second_nb], pcar[i] ) )
	     second_nb = i;
       }

       for( i=0;i<3;i++) {
	  if( s.nearby[i].who==second_nb && s.nearby[i].rel_y>CARLEN)
	      can_see_second = 1;
       }

       if( (gCar[s.my_ID].laps==gCar[second_nb].laps
	      && gCar[second_nb].when-gCar[s.my_ID].when>1200 ) )
	  can_see_second = 1;

       // if the second is more than one lap behind, slow down
       static int two_laps = 0;
       if( gCar[second_nb].laps<=gCar[s.my_ID].laps-2 ) {
	      two_laps = 1;
       }
       if( gCar[second_nb].laps>=gCar[s.my_ID].laps ) {
	      two_laps = 0;
       }

       // if 1 laps before the end the second car is visible
       // => don't overtake anymore (cool)
       if( s.laps_to_go > 1 ) can_see_end = 0;
       else if( can_see_second
	            || (gCar[s.my_ID].laps==gCar[second_nb].laps
	            && gCar[second_nb].when-gCar[s.my_ID].when>2000 ) )
	               can_see_end = 1;

       if( can_see_second || can_see_end || two_laps ) {
          bPassing4( s, /*alpha,*/ vc, 1.5 );
 	      return;
       }
    }

//// if the fuel is low, do not overtake  ( fuel 2.0 ~= 0.5 lap )
////  => don't want to overtake 2 times the same car :)
    if( s.fuel<2.0 ) 
    {
        bPassing4( s, /*alpha,*/ vc, 2.0 );
        return;
    }

//// if the damage is too high, stay alive
////  => don't overtake anymore
    if( s.damage>29000 ) 
    {
        bPassingNo( s, vc );
        return;
    }
    if( (s.damage>24000 && s.laps_to_go>5) || s.damage>25000  ) 
    {
        bPassing4( s, /*alpha,*/ vc, 2.0 );
        return;
    }

    if(( s.damage>10000 && s.damage<12000 ) 
    || ( s.damage>19000 ) 
    || ( gCpt<1000 && s.position>3 ) ) 
    {
        bPassing4( s, /*alpha,*/ vc, 1.5 );
    }
   
    bPassing4( s, /*alpha,*/ vc, 1.0 );
}
////////////////////////////////////////////////////////////////////////////

static void bOutOfTrack(  situation & s, double &alpha, double &vc )
{
   // prevent to go out of the track

   double f = 2.0;
   double vc2 = (300.0-min(200.0,vc))/300.0;

   // correct alpha if it predicts that the car goes out
   //  (not used during optimization)

   if (s.vn > (f*gToLft)) {
      alpha -= 0.2*( s.vn-f*gToLft );
   }
   if (-s.vn > (f*gToRgt)) {
      alpha += 0.2*( -s.vn-f*gToRgt );
   }
   // correct alpha if too close from the border
   if( gToLft<2.0 )
      if( gToLft>1.5 ) alpha += -(2.0-gToLft)*vc2;
		    else alpha += -0.5*vc2;
   if( gToRgt<2.0 )
      if( gToRgt>1.5 ) alpha += (2.0-gToRgt)*vc2;
		    else alpha += 0.5*vc2;

   vc = vc;
}
////////////////////////////////////////////////////////////////////////////

void bOtherCars( situation& s )
{
////
//// collect data about the other cars
////
  for( int i=0; i<car_count; i++ ) 
  {
      if( pcar[i]->Speed_avg!=gCar[i].old_avg ) 
      { // the car has finished a new lap
          gCar[i].laps++;
          gCar[i].when=gCpt;
	      gCar[i].old_avg=pcar[i]->Speed_avg;
      }
      // data from nearby
      gCar[i].bVisible = 0;
      for (int j=0; j<2; j++) 
      {
          if (s.nearby[j].who==i)
          {
              gCar[i].bVisible = 1;
              gCar[i].old_vx = ( (OLD_CPT_MIN-1.0)*gCar[i].old_vx + s.nearby[j].rel_xdot ) / OLD_CPT_MIN;
              gCar[i].old_vy = ( (OLD_CPT_MIN-1.0)*gCar[i].old_vy + s.nearby[j].rel_ydot ) / OLD_CPT_MIN;
              gCar[i].old_cpt += 1;
          }
      }
	  if( gCar[i].bVisible==0 ) 
      {
          gCar[i].old_vx = gCar[i].old_vy = 0.0;
          gCar[i].old_cpt = 0;
	  }
  }
}

////////////////////  D R I V E R   F U N C T I O N  ///////////////////////

////////////////////////////////////////////////////////////////////////////

static void bCalcInit( situation & s )
{
//// start curve
    if(gCpt==0) { 
       if( bTrackGetRay(1)>0.0 ) {
          gStartOut = gBorderOutAdj = gStartY;
       } else {
          gStartOut = gBorderOutAdj = gWidth-gStartY;
       }
       if( no_display ) gStartOut = gBorderOutAdj = 0;
    }
//// start 1st line or 2nd  line ?
    if(gCpt==1) { 
       gStartDist = s.position/4;
    }

//// calc the Slide Angle and the speed of the car, using the
////   acceleration to improve the precision.
////
    double ang = asin( s.vn/s.v );
    gVt = s.v * cos( ang );
    gVn = s.vn;

    // gCpt
    gCpt++;

    // the cen_a and tan_a are badly initialised
    if( gCpt>1 ) {
       // add the acceleration to the speed to predict the speed during the
       //  next calculation.
       gVt += s.tan_a * delta_time;
       gVn += s.cen_a * delta_time;
    }
    gVmag = sqrt( gVt*gVt + gVn*gVn );

////
//// init ToEnd
////
    gToEnd = bSegLength( s.cur_rad, s.to_end, gWidth );
    gCurSeg = s.seg_ID;     // current segment number, 0 to NSEG-1

    gToEnd -= 0.0;
    while( gToEnd<0.0 ) {
       gCurSeg++;
       if( gCurSeg==t.NSEG ) gCurSeg = 0;
       gToEnd += gTrack[gCurSeg].length;
    }

////
//// init segment number
////
    gNxtSeg = my_mod(gCurSeg+1,t.NSEG);
    gAftSeg = my_mod(gCurSeg+2,t.NSEG);
    gPrvSeg = my_mod(gCurSeg+t.NSEG-1,t.NSEG);

////
//// convert s.to_end to feets (for curves, don't want to work with radians :)
////
    gToLft = s.to_lft;
    gToRgt = s.to_rgt;

////
//// parameters for Curves
////
    gCurAngle = bTrackGetAngle(gCurSeg);
    gCurRadius = bTrackGetRay(gCurSeg);
    if(gCurRadius !=0.0 ) {
	gToEndAngle = s.to_end;
    }

////
//// convert s.cur_len, s.nex_len to feets (for curves)
////
    gCurLen = gTrack[gCurSeg].length;
    gNxtLen = gTrack[gNxtSeg].length;
    gAftLen = gTrack[gAftSeg].length;
    gHalf = gToEnd<gCurLen/2;
}

////////////////////////////////////////////////////////////////////////////

con_vec Bulle(situation& s)
{
  const char name[] = "Bulle";        // This is the robot driver's name!
  static int init_flag = 1;           // cleared by first call
  double alpha, vc;                   // components of result
  con_vec result;                     // This is what is returned
  static double prev_alpha;

  result.request_pit = 0;
  result.repair_amount = 0;

  if (init_flag)
  {
     my_name_is(name);                  // copy name over
     init_flag = 0;                     // reset init flag
     result.vc = STRAIGHT_SPD; result.alpha = 0;
	 return( result );
  }
  if (s.starting)
  {
  	 bInit();
	 gCpt = 0;
	 gAlphaOld=-1; gAlphaCpt=-1;
	 time_penality = 0;
	 prev_alpha = 0;
     ////
     //// get the start position
     ////
     gStartPos = int( s.to_rgt/(gWidth/4) );
     gStartDist = 0; // corrected when gCpt==1
     gStartY = s.to_rgt;
  }

  // init global variables
  bCalcInit( s );

  // get the car out of an abnormal condition, thanks Mitchell :)
  if( stuck( s.backward, s.v, s.vn, s.to_lft, s.to_rgt, &result.alpha, &result.vc ) )
	  return result;

  alpha = bCalcAlpha2( s );
  vc = bCalcVc3( s );
  alpha = alpha_limit( prev_alpha, alpha );
  if( !no_display ) bPassingMain( s, /*alpha,*/ vc );
  if( !no_display ) bOutOfTrack( s, alpha, vc );
  if( !no_display ) bOtherCars( s );

  #ifdef BULLE_HOME
    if( no_display ) 
	{
        double max;
        if( s.cur_rad==0.0 ) max = 6.5;
                        else max = 5.0;
        if( s.to_lft<max || s.to_rgt<max ) 
		{
            double f = min(s.to_lft,s.to_rgt);
            if( f<max-0.5 ) time_penality += 0.5;
	                   else time_penality += max-f;
        }
	}

    if( OPTI_PARAM2 ) 
	{
        if( gOptiCycle & 0x01 ) gBorderOutAdj = 2.0;
                           else gBorderOutAdj = 100.0;
    }
  #endif // BULLE_HOME


  alpha = alpha_limit(prev_alpha, alpha);
  prev_alpha = alpha;

  result.vc = vc;   result.alpha = alpha;

  if( s.laps_to_go>1	  )
  {
      if( s.fuel<5.0 ) 
	  {
          int cpt = min( 20, s.laps_to_go );
          int damage_min = max( s.damage-10000, 0 );
          result.request_pit   = 1;
  	      result.repair_amount = damage_min*cpt/20;
		  result.fuel_amount = MAX_FUEL;
	  }
      if( s.damage>25000 )
	  {
          int cpt = min( 20, s.laps_to_go );
          result.request_pit   = 1;
          result.repair_amount = max( s.damage*cpt/20, 5000 );
		  result.fuel_amount = MAX_FUEL;
      }
  }
  return result;
}

/////////////////////  E N D   O F   B U L L E . C P P  ////////////////////

